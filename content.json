{"meta":{"title":"X的博客","subtitle":"","description":"","author":"X","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Explain +load and +initlalize","slug":"Explain-load-and-initlalize","date":"2020-06-02T03:34:34.000Z","updated":"2020-06-02T04:06:16.080Z","comments":true,"path":"2020/2020-06-02-11:34:34/","link":"","permalink":"http://yoursite.com/2020/2020-06-02-11:34:34/","excerpt":"","text":"Explain +load and +initlalize+ (void)load;Apple文档是这样描述的： Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading. 当类（Class）或者类别（Category）加入Runtime中时调用。实现该方法，可以在加载时做一些类特有的操作。 Discussion The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond. The order of initialization is as follows: All initializers in any framework you link to.调用所有的Framework中的初始化方法 All +load methods in your image.调用所有的+load方法 All C++ static initializers and C/C++ attribute(constructor) functions in your image.调用C++的静态初始化方及C/C++中的attribute(constructor)函数 All initializers in frameworks that link to you.调用所有链接到目标文件的framework中的初始化方法 In addition: A class’s +load method is called after all of its superclasses’ +load methods.一个类的+load方法在其父类的+load方法后调用 A category +load method is called after the class’s own +load method.一个Category的+load方法在被其扩展的类的自有+load方法后调用 In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.在+load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的+load方法可能尚未被调用。 文档地址 load函数调用特点如下:当类被引用进项目的时候就会执行load函数(在main函数开始执行之前）,与这个类是否被用到无关,每个类的load函数只会自动调用一次.由于load函数是系统自动加载的，因此不需要调用父类的load函数，否则父类的load函数会多次执行。 当父类和子类都实现load函数时,父类的load方法执行顺序要优先于子类 类中的load方法执行顺序要优先于类别(Category) 当有多个类别(Category)都实现了load方法,这几个load方法都会执行,但执行顺序不确定(其执行顺序与类别在Compile Sources中出现的顺序一致) 当然当有多个不同的类的时候,每个类load 执行顺序与其在Compile Sources出现的顺序一致 + (void)initialize;Apple文档是这样描述的： Initializes the class before it receives its first message. 在这个类接收第一条消息之前调用。 Discussion The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. Runtime在一个程序中每一个类的一个程序中发送一个初始化一次，或是从它继承的任何类中，都是在程序中发送第一条消息。（因此，当该类不使用时，该方法可能永远不会被调用。）运行时发送一个线程安全的方式初始化消息。父类的调用一定在子类之前。 文档地址 initialize函数调用特点如下:initialize在类或者其子类的第一个方法被调用前调用。即使类文件被引用进项目,但是没有使用,initialize不会被调用。由于是系统自动调用，也不需要再调用 [super initialize] ，否则父类的initialize会被多次执行。假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。 父类的initialize方法会比子类先执行 当子类未实现initialize方法时,会调用父类initialize方法,子类实现initialize方法时,会覆盖父类initialize方法. 当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个(会执行Compile Sources 列表中最后一个Category 的initialize方法) 我们在Teacher(继承Person).m中不实现initialize方法： 1&#x2F;&#x2F;In Person.m2+(void)initialize3&#123;4 NSLog(@&quot;%s&quot;,__FUNCTION__);5&#125;67&#x2F;&#x2F;In Teacher.m(继承自Person)89Teacher.m中不实现initialize方法 我们调用下Teacher的new方法,运行： 1[Teacher new]; 运行结果： 12017-05-04 14:06:45.051 LoadAndInitializeExample[29238:912579] +[Person initialize]22017-05-04 14:06:45.051 LoadAndInitializeExample[29238:912579] +[Person initialize] 运行后发现父类的initialize方法竟然调用了两次：可见当子类未实现initialize方法,会调用父类initialize方法.但为什么会打印2次呢?我的理解:子类不实现initialize方法，会把继承父类的initialize方法并调用一遍。在此之前,父类初始化时,会先调用一遍自己initialize方法.所以出现2遍,所以为了防止父类initialize中代码多次执行,我们应该这样写: 1&#x2F;&#x2F;In Person.m2+(void)initialize3&#123;4 if(self &#x3D;&#x3D; [Person class])5 &#123;6 NSLog(@&quot;%s&quot;,__FUNCTION__);7 &#125;8&#125; 下面我们在 Teacher.m中实现initialize方法 1&#x2F;&#x2F;In Person.m2+(void)initialize3&#123;4 NSLog(@&quot;%s&quot;,__FUNCTION__);5&#125;67&#x2F;&#x2F;In Teacher.m(继承自Person)8+(void)initialize9&#123;10 NSLog(@&quot;%s&quot;,__FUNCTION__);11&#125; 同样调用Teacher 的new方法,运行： 1[Teacher new]; 运行结果: 12017-05-04 14:07:45.051 LoadAndInitializeExample[29238:912579] +[Person initialize]22017-05-04 14:07:45.051 LoadAndInitializeExample[29238:912579] +[Teacher initialize] 可以看到 当子类实现initialize方法后,会覆盖父类initialize方法,这一点和继承思想一样。 什么情况下使用： +load由于调用load方法时的环境很不安全，我们应该尽量减少load方法的逻辑。另一个原因是load方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在load方法中 load很常见的一个使用场景,交换两个方法的实现： 1&#x2F;&#x2F;摘自MJRefresh2+ (void)load3&#123;4 [self exchangeInstanceMethod1:@selector(reloadData) method2:@selector(mj_reloadData)];5 [self exchangeInstanceMethod1:@selector(reloadRowsAtIndexPaths:withRowAnimation:) method2:@selector(mj_reloadRowsAtIndexPaths:withRowAnimation:)];6 [self exchangeInstanceMethod1:@selector(deleteRowsAtIndexPaths:withRowAnimation:) method2:@selector(mj_deleteRowsAtIndexPaths:withRowAnimation:)];7 [self exchangeInstanceMethod1:@selector(insertRowsAtIndexPaths:withRowAnimation:) method2:@selector(mj_insertRowsAtIndexPaths:withRowAnimation:)];8 [self exchangeInstanceMethod1:@selector(reloadSections:withRowAnimation:) method2:@selector(mj_reloadSections:withRowAnimation:)];9 [self exchangeInstanceMethod1:@selector(deleteSections:withRowAnimation:) method2:@selector(mj_deleteSections:withRowAnimation:)];10 [self exchangeInstanceMethod1:@selector(insertSections:withRowAnimation:) method2:@selector(mj_insertSections:withRowAnimation:)];11&#125;1213+ (void)exchangeInstanceMethod1:(SEL)method1 method2:(SEL)method214&#123;15 method_exchangeImplementations(class_getInstanceMethod(self, method1), class_getInstanceMethod(self, method2));16&#125; ####+initialize initialize方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如NSMutableArray这种类型的实例化依赖于runtime的消息发送，所以显然无法在编译器初始化： 12&#x2F;&#x2F; In Person.m3&#x2F;&#x2F; int类型可以在编译期赋值4static int someNumber &#x3D; 0; 5static NSMutableArray *someArray;6+ (void)initialize &#123;7 if (self &#x3D;&#x3D; [Person class]) &#123;8 &#x2F;&#x2F; 不方便编译期复制的对象在这里赋值9 someArray &#x3D; [[NSMutableArray alloc] init];10 &#125;11&#125; 总结：load和initialize的共同点1.如果父类和子类都被调用,父类的调用一定在子类之前； +load方法要点 当类被引用进项目的时候就会执行load函数(在main函数开始执行之前）,与这个类是否被用到无关,每个类的load函数只会自动调用一次.由于load函数是系统自动加载的，因此不需要再调用[super load]，否则父类的load函数会多次执行。 当父类和子类都实现load函数时,父类的load方法执行顺序要优先于子类 类中的load方法执行顺序要优先于类别(Category) 当有多个类别(Category)都实现了load方法,这几个load方法都会执行,但执行顺序不确定(其执行顺序与类别在Compile Sources中出现的顺序一致) 当然当有多个不同的类的时候,每个类load 执行顺序与其在Compile Sources出现的顺序一致 注意: load调用时机比较早,当load调用时,其他类可能还没加载完成,运行环境不安全. load方法是线程安全的，它使用了锁，我们应该避免线程阻塞在load方法. +initialize方法要点 initialize在类或者其子类的第一个方法被调用前调用。即使类文件被引用进项目,但是没有使用,initialize不会被调用。由于是系统自动调用，也不需要显式的调用父类的initialize，否则父类的initialize会被多次执行。假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。 父类的initialize方法会比子类先执行 当子类未实现initialize方法时,会调用父类initialize方法,子类实现initialize方法时,会覆盖父类initialize方法. 当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个(会执行Compile Sources 列表中最后一个Category 的initialize方法) 注意: 在initialize方法收到调用时,运行环境基本健全。 initialize内部也使用了锁，所以是线程安全的。但同时要避免阻塞线程，不要再使用锁","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"SEL和Method和IMP详解","slug":"SEL和Method和IMP详解","date":"2020-06-01T03:45:31.000Z","updated":"2020-06-02T04:06:05.995Z","comments":true,"path":"2020/2020-06-01-11:45:31/","link":"","permalink":"http://yoursite.com/2020/2020-06-01-11:45:31/","excerpt":"","text":"SEL和Method和IMP分别说下，再谈下对IMP的理解在 Objective-C 中，selector，Method 和 implementation(IMP) 都是 Runtime 的组成部分。在实际开发中它们常常可以相互转换来处理消息的发送。Selector定义：typedef struct objc_selector *SEL翻译成中文叫做选择子或者选择器，选择子代表方法在 Runtime 期间的标识符。为 SEL 类型，虽然 SEL 是 objc_selector 结构体指针，但实际上它只是一个 C 字符串。在类加载的时候，编译器会生成与方法相对应的选择子，并注册到 Objective-C 的 Runtime 运行系统。 常见的有两种方式来获取/创建选择子: 1SEL selA &#x3D; @selector(setString:);2SEL selB &#x3D; sel_registerName(&quot;setString:&quot;); 从 sel_getName() 方法的源码可以看出 SEL 和 const char * 是可以相互转化的： 1const char *sel_getName(SEL sel) &#123;2 return sel ? (const char *)sel : &quot;&lt;null selector&gt;&quot;;3&#125; 如果将 selA 和 selB 强转为为 const char *: 1(lldb) p (const char *)$22(const char *) $3 &#x3D; 0x00007fff9a3794b5 &quot;setString:&quot;3(lldb) p (const char *)$14(const char *) $4 &#x3D; 0x00007fff9a3794b5 &quot;setString:&quot;5(lldb) 上面的结果可以看出，selA 和 selB 指向相同的地址，代表同一个字符串。 如果某个类实现了 setString：方法，那么以上两个选择子传入 respondsToSelector() 方法返回的结果都将为 YES。 不同类中相同名字的方法所对应的方法选择子是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择子。 Implementation(IMP): 定义：typedef id (*IMP)(id, SEL, ...) 代表函数指针，即函数执行的入口。该函数使用标准的 C 调用。第一个参数指向 self（它代表当前类实例的地址，如果是类则指向的是它的元类），作为消息的接受者；第二个参数代表方法的选择子；… 代表可选参数，前面的 id 代表返回值。 举个AF中的源码例子： 1 NSURLSessionConfiguration *configuration &#x3D; [NSURLSessionConfiguration ephemeralSessionConfiguration];2 NSURLSession *session &#x3D; [NSURLSession sessionWithConfiguration:configuration];3#pragma GCC diagnostic push4#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;5 NSURLSessionDataTask *localDataTask &#x3D; [session dataTaskWithURL:nil];6#pragma clang diagnostic pop7 IMP originalAFResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));8 Class currentClass &#x3D; [localDataTask class];9 10 while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;11 Class superClass &#x3D; [currentClass superclass];12 IMP classResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));13 IMP superclassResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));14 if (classResumeIMP !&#x3D; superclassResumeIMP &amp;&amp;15 originalAFResumeIMP !&#x3D; classResumeIMP) &#123;16 [self swizzleResumeAndSuspendMethodForClass:currentClass];17 &#125;18 currentClass &#x3D; [currentClass superclass];19 &#125; Method定义：typedef struct objc_method *MethodMethod 对开发者来说是一种不透明的类型，被隐藏在我们平时书写的类或对象的方法背后。它是一个 objc_method 结构体指针，objc_method 的定义为： 1&#x2F;&#x2F;&#x2F; Method2struct objc_method &#123;3 SEL method_name; 4 char *method_types;5 IMP method_imp;6&#125;; 方法名 method_name 类型为 SEL，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。 方法类型 method_types 是个 char 指针，其实存储着方法的参数类型和返回值类型，即是 Type Encoding 编码。 method_imp 指向方法的实现，本质上是一个函数的指针，就是前面讲到的 Implementation。 举个AF中的源码例子： 1static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;2 Method originalMethod &#x3D; class_getInstanceMethod(theClass, originalSelector);3 Method swizzledMethod &#x3D; class_getInstanceMethod(theClass, swizzledSelector);4 method_exchangeImplementations(originalMethod, swizzledMethod);5&#125; 应用场景： When we use method swizzling 1+ (void)load &#123;2 static dispatch_once_t onceToken;3 dispatch_once(&amp;onceToken, ^&#123;4 Class class &#x3D; [self class];5 6 SEL originalSelector &#x3D; @selector(prepareToPlay);7 SEL swizzledSelector &#x3D; @selector(recond_prepareToPlay);8 9 Method originalMethod &#x3D; class_getInstanceMethod(class, originalSelector);10 Method swizzledMethod &#x3D; class_getInstanceMethod(class, swizzledSelector);11 12 BOOL didAddMethod &#x3D; class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));13 &#x2F;*14 @return YES if the method was added successfully, otherwise NO (for example, the class already contains a method implementation with that name).15 如果方法添加成功，则返回YES，否则返回NO（例如，类已包含具有该名称的方法实现）16 *&#x2F;17 if (didAddMethod) &#123;18 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));19 &#125; else &#123;20 method_exchangeImplementations(originalMethod, swizzledMethod);21 &#125;22 &#125;);23&#125; Selector，Method，IMP 它们之间的关系可以这么解释：一个类（Class）持有一个分发表，在运行期分发消息，表中的每一个实体代表一个方法（Method），它的名字叫做选择子（SEL），对应着一种方法实现（IMP）。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"组件化方案","slug":"组件化方案","date":"2020-05-23T08:27:28.000Z","updated":"2020-05-23T09:07:34.130Z","comments":true,"path":"2020/2020-05-23-16:27:28/","link":"","permalink":"http://yoursite.com/2020/2020-05-23-16:27:28/","excerpt":"","text":"BeeHive框架全面解析——iOS开发主流方案比较• BeeHive框架全面解析——iOS开发主流方案比较• 一、BeeHive是什么？• 二、作为框架，BeeHive做了什么工作？• 三、BeeHive是怎么做应用代理解耦的？• BeeHive应用代理解耦• MLSOAppDelegate应用代理解耦• 应用代理解耦讨论• 四、BeeHive是怎么做模块间调用的？• BeeHive模块调用• CTMediator模块调用• 模块间调用的讨论• 五、BeeHive的开发支持功能• 六、我们的方案选择• Objective-C是否适合POP开发？• 选择方案• 参考文档 一、BeeHive是什么？ BeeHive是用于iOS应用开发的App模块化编程的框架实现方案，吸收了Spring框架Service的理念来实现模块间的API耦合。BeeHive框架代码已在GitHub开源，对这个框架不了解的同学可以先看一下开源库提供的介绍：BeeHive@github。 二、作为框架，BeeHive做了什么工作？ BeeHive框架提供的功能主要有以下几部分：• 应用代理解耦：解除AppDelegate代理方法中，不同业务代码的耦合。• 模块间调用解耦：解除不同模块间的\b过度耦合问题，提供更加清晰的调用方案。• 其他开发支持功能 三、BeeHive是怎么做应用代理解耦的？AppDelegate中的代码想要解除耦合，说到底还是要将代理事件分发到不同的业务代理类中。在BeeHive之前，我自己用过两种解耦组件：• FRDModuleManager：实现代理中所有方法，简单的将AppDelegate的单路代理改成多路代理。• MLSOAppDelegate：通过runtime的事件转发，将代理协议中的方法进行动态转发，在自己代码中没有实现所有代理方法。不知道还有没有其他的\b开源组件，单论以上两种，MLSOAppDelegate应该算是FRDModuleManager的增强版，所以下面我们把MLSOAppDelegate的方案来和BeeHive的方案进行比较。 笔者说明：一般\b应用代理解耦的文章会将代理事件分发到的类称之为模块module，但是为了和下部分“模块间调用”中的模块概念区分，我们就将应用代理解耦中常用的Module称之为“模块代理类”。 BeeHive应用代理解耦统一基类 + 全局上下文参数 + 事件二次分发BeeHive提供了统一的AppDelegate基类BHAppDelegate，所有代理事件的参数全部保存到全局上下文对象BHContext中，由管理模块代理类的BHModuleManager从BHContext里把参数取出来然后通过BHModuleEventType枚举类型进行二次分发。将模块代理类注册进BHModuleManager，BeeHive提供了多种方法： 在模块代理类+ (void)load方法中调用[BeeHive registerDynamicModule:[self class]];; 在模块代理类的implementation中插入宏BH_EXPORT_MODULE(NO);此方法实质上和上面相同； 类似Java注解的形式@BeeHiveMod(ShopModule); 通过[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;指定的文件加载。 应用代理解耦功能涉及到的类型有：• BHAppDelegate• BHModuleProtocol• BHModuleManager• BHAnnotation• BHContext \b优点： 业务代码的AppDelegate只要继承基类，不需要实现具体的代理方法； 扩展了模块生命周期\b，增加了modSetUp、modInit和modSplash方法； 模块代理类在业务代码中注册或者模块代理类自动注册时，会按照Level和Priority进行排序，模块代理类被调用的顺序可控； 模块代理类支持异步加载； 支持自定义事件。 不足： 因为有统一基类，对业务代码有侵入； 因为BeeHive对AppDelegate方法进行了\b二次封装，所以当系统代理方法增加、删除、变动时，BeeHive需要同步修改； 通过Level和Priority进行模块代理类的排序，其实质上存在逻辑耦合； 未支持UIResponder中的事件； MLSOAppDelegate应用代理解耦统一基类 + 事件转发该组件提供了基类MLSOAppDelegate，基类使用forwardInvocation将接收到的方法全部转发到MLAppServiceManager管理的所有模块代理类列表中。注册模块代理类，该组件也提供了多个方法： 通过MLAppServiceManager的registerServiceWithPlistFile方法加载配置文件； 在模块代理类+ (void)load方法中调用registerService方法; 通过ML_EXPORT_SERVICE宏定义自动注册；实质与上一种相同；优点： 业务代码的AppDelegate只要继承基类，不需要实现代理方法； 现有代理协议的方法增减变动时不需要同步修改； 通过配置文件主动注册时，调用顺序可控；不足： 需要支持新的协议时，需要同步修改；比如iOS10系统的推送； 在load方法内自动注册时，调用顺序不可控； 未分发UIResponder中的事件； 应用代理解耦讨论通过上面的比较，两种方案的区别主要在于模块代理类的执行顺序以及对代理方法变动的兼容性两方面。 模块代理类的执行顺序模块代理类的执行顺序只是个逻辑问题，相对来说BeeHive的方案比较满足我们的业务要求。不过我们在此不妨思考一下，模块代理类的执行顺序实质上是个什么问题。所谓的顺序，我们拆分到最细的层次上，其实就是两个模块代理类谁先谁后的问题。那么，执行顺序的问题，实质上就是模块\b代理类之间的耦合问题。耦合关系一般是两者之间的，所以解决问题时具体方案涉及的对象一旦超出了两者，那么就存在冗余的耦合。而通过Priority进行控制就是这样的方案。比如，现有A，B，C，D四个模块，其中B依赖A，C依赖B，D依赖A，那么现在设定他们的Priority分别为A=1，B=10，C=20，D=30（\b数字越小优先级越高）。但是有一天，因为新的需求，B模块也需要依赖D模块了。那么按照Priority的规则，我们需要调整B的Priority，使之大于D的Priority，比如设置B=40。但这样设置的话就破坏了C依赖B的关系。当然，我们也可以将D的Priority\b设置为比B更小，这样就不会有问题。但是我们在这里举这个例子的\b目的在于解释，Priority的方案会使得模块间的依赖关系更加复杂，两个模块间的依赖关系可能影响到其他模块间的依赖关系。那么，如果回归到最理想的状态，我们是否可以通过模块代理类间的耦合关系指定相对的加载顺序，\b类似Masonry这样的布局组件。比如： 1• + (void)load &#123;2• [[FWModuleDelegateManager sharedInstance] registeModuleDelegate:[FWPushModuleDelegate class] forName:@&quot;FWPush&quot; after:@[@&quot;FWUserCenterModuleDelegate&quot;, @&quot;FWLocationModuleDelegate&quot;]];3• 4• [[FWModuleDelegateManager sharedInstance] registeModuleDelegate:[FWPushModuleDelegate class] forName:@&quot;FWPush&quot; forIndex:0];5• &#125; 当然，我们上面的代码只是个简单的设想，实际的实现可能会更加复杂，比如，如果考虑到BeeHive支持的模块代理类异步加载的特性，那么这个相对执行顺序的方案可能就需要通过信号量或者队列的手段来确保不同线程下模块代理类的执行顺序了。在这里，本文暂时只做讨论，不给出实际方案。 代理方法变动的兼容性如果说上一个问题实际上只是个逻辑问题，并不存在技术可能性上的是与非。那么对代理方法变动的兼容性，则是技术方案的实质所在。以BeeHive的方案，实际上是抛弃了灵活性的考量，这样限制了它在这一点上的优化空间。 四、BeeHive是怎么做模块间调用的？模块间调用解决的是模块间的依赖耦合问题。常见的处理方案有以下三种：• URLRouter：将不同的模块定义成为不同的URL，通过URL的形式进行跨模块调用。• Target-Action：利用OC的runtime能力，动态的调用指定Target的action；• ProtocolClass：模块实现指定的协议，依赖方通过协议对象以及协议方法对模块进行访问；路由的方案限制比较多，我们在此比较一下后两种方案。BeeHive模块调用ProtocolClass / RouterBeeHive的模块都必须实现一个继承自BHServiceProtocol的唯一自定义协议，此协议中定义自己想要公开的方法，是用来给其他模块调用使用的。每个模块的自定义协议可以统一放在一个pod中，以中介者模式解决网状依赖的问题。而且该pod只会被具体的模块依赖，并不会依赖具体的模块。完全符合面向对象的依赖倒置原则——抽象不应该依赖于具体实现，具体实现应该依赖于抽象。将模块注册进入BHServiceManager中，BeeHive也提供了多种方法： 在模块代理类中手动注册[[BeeHive shareInstance] registerService:@protocol(TradeServiceProtocol) service:[BHTradeViewController class]];; 通过注解的形式注册@BeeHiveService(HomeServiceProtocol,BHViewController); 通过[BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;指定的配置文件加载。BeeHive另外还提供了\b通过路由BHRouter进行模块间调用的方案。模块间调用涉及的类型有：BHServiceProtocolBHServiceManagerBHRouter 不足： 有基础协议，存在代码\b侵入，但其中并未封装通用性的协议方法； BHServiceManager注册时通过协议识别模块，因此每个模块必须定义自己的协议； 通过配置文件注册时，未提供属性注入； 因为模块通过BeeHive统一注册后创建，所以Service之间的依赖，可能导致Service在注册前使用；因而需要控制Service的加载顺序；优点： 模块不存在\b或未注册时，不会获取到实例，可以灵活处理；另外，因为暂时没有弄清BHRouter的使用场景，我实在分不清“支持Router式调用”这是BeeHive框架的优点还是不足。 CTMediator模块调用Target-ActionCTMediator的方案中，每个模块需要定义自己的Target对象，作为公共方法声明，其中定义的Action都是给其他模块调用使用的。为了解决网状依赖的问题，可以为每个模块定义一个CTMediator\b的category对Target进行二次封装，这些category放在统一的pod中，作为一个中介者。按正常的逻辑，这个统一pod是会依赖具体的模块的，但是CTMediator的方案中，是利用runtime调用对应的Target-Action，所以解除了直接的代码依赖。不足： Target无基础类型，缺乏抽象，模块需要自己实现Target-Action; 当模块不存在时，无法\b提前处理，只能设置默认处理方法； category中都是硬编码，修改时会比较麻烦。优点： Target无基础类型，所以无侵入性； 模块不需注册; 两层封装，保证灵活性； 和应用间的Route跳转可以更灵活的对接； 模块间调用的讨论这个模块间调用的问题其实就是“依赖倒置”\b所解决的问题。BeeHive的方案应该是\b依赖倒置原则的标准实现方案，而CTMediator则是充分使用了OC的特性剑走偏锋。而CTMediator之所以需要这样处理，实质上就是因为它追求代码的无侵入性以及免注册，所以Target没有统一的基础类型。如果增加一个基础的Target类，同样可以像BeeHive\b的方案一样，完美的符合依赖倒置原则。而哪个适合你，就要看自己的取舍了。 五、BeeHive的开发支持功能• 环境切换：BHContext类中定义了env用来标识当前的环境类型，只不过这个功能太简单了些。• 时间统计工具：BHTimeProfiler• 看门狗，用来检测主线程占用：BHWatchDog因为本次重点是讨论框架，所以这些内容暂不详述。 六、我们的方案选择Objective-C是否适合POP开发？POP：Protocol-Oriented Programming在\b看了这么多框架的优劣后，想请大家思考个问题：Objective-C开发是否适合面向协议编程？我个人觉得\bPOP的关键点有两点，一是声明与实现的隔离，二是对于多态的支持。而对于Objective-C来说，声明与实现的隔离，这在.h与.m中已经实现，虽然只是表面的，并没有做到完全解耦；但很多时候的封装性已经可以满足。而对于多态的支持，很多时候其实就是程序能力的扩展，在这一方面Objective-C是通过Category实现的。因此，OC对于POP似乎没有迫切的需求。 选择方案本着学以致用的原则，我们如果要开发项目，需要选定一个确定的框架方案，那么综合以上的分析比较，我个人的倾向方案是：基于MLSOAppDelegate进行优化，增加BeeHive的优点（支持顺序设定、异步加载），支持相对顺序 + 基于CTMediator进行优化（增加Target预检测），\b业务层增加部分抽象以上是我的答案，如果是你，你会选择什么呢？ 参考文档 BeeHive，一次iOS模块化解耦实践 BeeHive —— 一个优雅但还在完善中的解耦框架 iOS大型项目解耦方案有难度？BeeHive设计优化来帮助 BeeHive@github","categories":[{"name":"架构知识","slug":"架构知识","permalink":"http://yoursite.com/categories/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"组件化","slug":"组件化","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"架构概念","slug":"架构概念","date":"2020-05-23T08:26:15.000Z","updated":"2020-05-23T08:35:40.743Z","comments":true,"path":"2020/2020-05-23-16:26:15/","link":"","permalink":"http://yoursite.com/2020/2020-05-23-16:26:15/","excerpt":"","text":"组件、插件、模块、子应用、库、框架等概念辨析网上有许多讲组件化、模块化等概念的文章，但大家一般都是将这两个概念混为一谈的，并没有加以区分。而且实际上许多人对于组件、插件、模块、子应用等概念的区别也不甚明了，甚至于许多博客文章专门解说这几个概念都有些谬误。之前已经写了一篇文章专门对组件和模块两个概念进行辨析，现在我们对于更多的概念在更高的层次上进行辨析。想分清这几个概念我觉得结合一下软件的渐进式开发场景更容易理解。但是下面的篇幅会比较长，所以按惯例还是先说结论，不耐烦的同学可以先看： 1.概念区别• 组件：代码重用，功能相对单一或者独立，无统一接口。组件化开发的成果是基础库和公共组件。• 插件：近乎组件，有统一接口• 模块：高内聚，松耦合，功能相对复杂，有多个统一接口。模块化开发的基础是框架。• 子系统：高于模块，需要生命周期管理。子系统开发的基础是容器。 1.1.组件和插件插件的概念比较形象，一般存在一个“插拔”过程，所以要求可插拔的插件有一个相同的接口（这里所说的接口只是概念上的接口，即调用方法及参数等）。而组件是不存在这个\b相同接口的。拿我们最常见的网络请求功能举例，无论哪种开发语言，github上可能都有多种网络请求组件，那么对于一个\b项目而言，从一个\b网络组件ComponentA切换为另一个网络组件ComponentB是基本无法做到调用方法不改动的。而如果把网络请求组件插件化，即在组件外层抽象一层\b统一化的调用接口NetworkInterface，然后将当前使用网络请求组件ComponentA包装成实现该接口的网络请求插件PluginA。那么如果以后需要将使用的ComponentA切换为ComponentB，那么只需要将ComponentB包装成PluginB并插入到应用中\b即可。实际调用时，业务代码还是调用NetworkInterface，不用做任何修改。从上面这个例子我们可以看出，插件和组件的\b实质区别就在于通过统一接口隔绝业务代码对于组件的直接依赖，这也是我们常听到的所谓的“项目开发时应该把第三方组件封装一下再用”。 1.2.组件和模块两者的实质区别在于：组件化开发是纵向分层，模块化开发是横向分块。所以，模块化并没有要求一定组件化，就是说进行模块化拆分时你可以完全不考虑代码重用，只是把同一业务的代码做内聚整合成不同的模块。只不过这样得到的成果相对简单，我们一般不会这样而已。组件化就比如项目中公共的alert框，它的出现其实是基于代码复用的目的，所以我们把它封装，并给多个地方使用。而模块化就比如一个资讯列表界面，它本身可能只在一个地方使用，没有复用的需求，但我们也要把它封装成模块，这是高内聚的要求，我们不应该把资讯相关的代码在项目中放得到处都是。但像这样的简单模块只是轻模块，统一接口较少。而统一定义的接口越多，其实和主应用的耦合就越高，也便是重模块。而路由就是解决高耦合问题的，不过耦合问题不是模块化开发的需求，只不过我们一般都会在这个时间考虑这一事情而已，就像我们不会只做模块化开发同时不做组件化开发一样。 1.3.模块和子应用模块和子应用的区别与组件和插件的区别有点像，都在于一个统一接口。子应用我们不常提，但其实并不少见，像微信小程序，钉钉中的第三方应用还有企业OA应用中集成的周边功能模块都应该属于子应用的概念。对于模块而言，它暴露给\b外部调用的接口一般很少，最常见的就是上面提到的路由规则，相当于可以让外部通过路由规则展示它。而子应用需要的就不只是一个展示接口，它可能需要动态的控制子应用的生命周期，以及其他功能上的信息交互（比如，账户信息的同步），甚至于要做到类似插件那样的插拔效果。所以子应用必然是接口化的，而模块则没有硬性的要求。 1.4.库和框架除了上面这四种概念，还有两个是我们开发中常遇到的：库和框架。库，或者基础库，概念上偏近于各种工具\b积累成的集合，是软件代码的层面是分层的概念，所以对应组件化。基础库甚至可以看做是一个大的组件。而框架顾名思义是结构化的，是相对整体的一个概念，所以应用于模块化，甚至是子应用化。比如在iOS中，RAC是一个库，而基于此的一套MVVM的具体实现成果（单页面的文件结构，多页面的交互等等）才叫框架。因为框架本身就有架构思想在里面。 2.渐进式辨析上面讲了一下几个概念的区别，当然这几个概念在服务端开发和客户端开发领域可能有些微差别，我们就不深究了。想要更深入的了解这些概念的区别，我准备拿一个渐进式开发移动端项目的例子进行辨析。首先我们定义一个虚拟的产品——一款知识类应用，包含常见的资讯、问答、学院、直播等功能。接下来我们从设计的角度逐步拆分这个产品。 2.1原始态如果开发时没有考虑任何组件化、模块化开发，那么此应用的所有功能都是堆积在一起的，总结起来就是代码特点就是高耦合，低内聚，无重用。面对这样的一堆代码，\b技术经理可能要让你做一下代码重构，这就是你下一步的工作。 2.2组件\b那么你进行代码重构的第一步是什么呢？答：将工程中重复的代码合并成为一份，也就是重用。如果让我们来看组件化开发的定义，它的着重点就是代码重用。那这一步最后的结果就是提炼出一个个组件给不同的功能使用。这里我们可以看一下其中的依赖关系：具体功能依赖提炼出来的组件，组件本身之间可能也有依赖关系，但一般不多。所以我们总结组件化开发的原则就是高重用，低耦合。当然这只是相对而言。基于这样的认识，我们甚至于可以把资讯、问答、学院、直播等功能封装成组件，只不过这些组件比较大，依赖可能多些，不过本质上没有多少区别。就在你进行重构的过程中，这时需求来了：运营人员要求首页顶部的九宫格样式工具栏可动态配置，通过服务端数据修改显示功能，并调用对应的功能页面。 2.3插件代码重构从来不是超然物外的，在进行过程中接到新需求也是常有的事情。那么，对于这样一个需求，应该怎么考虑呢？这个动态化需求很普遍，只不过这里有一个隐性要求——既然需求中要求功能动态配置，那么调用功能的地方就不知道功能的具体实现。所以最终的方案中被调用功能必须有统一接口。我们这里说的接口只是编程领域的抽象概念，并非是指具体语言的interface或者protocol。而有了这一统一接口，其配置功能其实就是“插拔”\b过程了。这样的成果实质上已经是插件了。插件可以解释成可插拔式组件，它的核心就是不同功能实现提供统一接口。项目中插件化的例子其实也不少，再举一个例子：比如资讯和问答功能使用的弹框样式不同，但是在两个功能内部其弹框样式是一致的。面对这样的问题，你在重构时可能会简单的封装出两个组件AlertA和AlertB，分别给两个功能使用。这样确实很便捷，而且适合当下的场景，但是从设计或者长远发展的角度上来考虑，如果资讯里面弹框样式需要\b换成和问答一样，甚至其他样式，那么基于现有的方法，你就需要修改资讯功能中所有调用弹框的地方。所以插件化是解决这个问题的好办法：定义AlertInterface接口给具体业务功能使用，并实现AlertPluginA、AlertPluginB，在外面给不同的功能指定不能的插件即可。 2.4模块这时候项目的组件化拆分完成，技术经理说以后不同的模块会交由不同的人来维护，各人维护各自负责的代码。这个需求初看上去只是项目管理上的需求，但实际执行时若资讯、问答、学院、直播分别由四个人维护，那么他们虽然大部分代码是相互隔离的，但仍然会有相当\b一部分代码耦合在一起，有时候会同时修改同一个代码文件。这时候要做的自然就是模块化。为什么是模块化呢？按照模块的定义，它是以关注点进行划分的，而关注点说到底就是功能，也就是说根据我们上面的例子，资讯、问答、学院、直播可以分成不同的模块。我们最开始定义这个虚拟产品的时候说，它有三个特点——高耦合、低内聚、无重用。而第一点组件化开发主要是解决了重用问题，提升了部分内聚，而耦合问题则没有涉及。所以说我们上面可以将这个产品在逻辑上划分为资讯、问答、学院、直播四个模块，但在代码层面上它们却不是四个模块，因为它们的代码都是混杂在一起的。比如产品首页，可能推荐了部分资讯、显示了热门问答、推送了目前的直播，而这些功能的代码则是写在一起的；再比如程序启动的时候，这四个模块都需要初始化一些数据，而初始化数据的代码也是写在一起的。而模块化开发就是为了解决这一问题，即提高内聚，将分属同一模块代码放到一起；降低耦合，将不同模块间的耦合程度弱化。高内聚是这一步的目标。但现状是有许多地方会用到多个模块，比如启动的时候会调用四个模块，首页会展示三个模块的界面。如果要高内聚，那么必然需要这些模块为不同的场景提供相同的方法，这就是说所有模块要实现同一套多个接口。而低耦合其实并非是模块化开发的要求，其实更多时候是基于产品上的动态化要求，所以最常见的解决方案就是路由机制。讲到这里，我们可以看到模块化和组件化的区别就已经很明显了。对于一般应用而言，代码设计优化到这一步就很好了，无论是代码可读性、可维护性、工作协作效率都得到了保障。不过为了讲到我们上面\b所说的所有概念，我们不妨皮一下，给自己提点需求：产品经理想把学院模块单独提出来做一个APP，但是因为技术经理反映\b开发资源有限，不能给这个APP配备独立的开发人员，所以最终的结果是这个APP的功能和原应用中的学院模块使用同一套代码，且功能相同。 2.5子应用对于开发人员来说，这也不能算多困难的需求，只需要再创建一个新工程，将学院模块代码引用过来并显示即可。这个方案简单直接，即便后面再把直播分离出单独APP我也可以这样来做。但是，有没有\b觉得这个方案和我们之前提到的Alert的例子有些神似，在这个方案中，新的工程必然直接耦合具体的模块代码，你需要在里面编写很多初始化代码。而这样的代码在单独的APP中和原APP中是相当类似的。按照《重构》一书中的提法，这是明显的坏味道，我们应该在工程和模块代码之间抽象出一层接口，使两者解除直接耦合，这样我们甚至可以做到只需要配置就可以将一个模块变成一个新的APP。(或许在这个例子中，有些过度设计了，但是原谅我举不出更合情理的例子TAT)上面方案的成果，实际上就把学院模块编程了学院子应用，而这个子应用被原APP和新的独立APP所使用。在概念上，子应用比模块的范围更大，子应用要求能在主应用里运行，也要求必要时可以自己运行，那么就必然要求子应用要提供生命周期接口，和主应用必要时保持一致。其实在\b上面一步的模块化开发中，有的时候也会有生命周期接口的要求，只不过并非强制，而子应用的设计中则是必须要考虑的。 3.总结到此，我们就把组件、插件、模块、子应用四个不同程度的设计概念\b异同讲完了，希望读者能有所得。文章中若有其他不足之处，恳请不吝赐教。","categories":[{"name":"架构知识","slug":"架构知识","permalink":"http://yoursite.com/categories/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"架构概念","slug":"架构概念","permalink":"http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5/"}]},{"title":"随手记录📝","slug":"日常笔记📒","date":"2020-03-19T07:40:37.000Z","updated":"2020-05-23T08:15:52.911Z","comments":true,"path":"2020/Thu Mar 19 2020 15:40:37 GMT+0800 (中国标准时间)/","link":"","permalink":"http://yoursite.com/2020/Thu%20Mar%2019%202020%2015:40:37%20GMT+0800%20(%E4%B8%AD%E5%9B%BD%E6%A0%87%E5%87%86%E6%97%B6%E9%97%B4)/","excerpt":"UML类图","text":"UML类图 —————▷ 继承———–▷实现接口 —————&gt; 关联———–&gt; 依赖 ◆————&gt; 组合◇————&gt; 聚合 ◦ 接口 一些传送门设计模式 [iTerm2] (https://www.cnblogs.com/xishuai/p/mac-iterm2.html) /用户/Xuebiao/Library/Developer/Xcode/usr/local/bin ../ 上层目录./ 当前目录cal 日历时间bc 计算器 quit退出cd - 上次查看的目录cd .. 返回上层目录cd 根目录 快捷键：显示隐藏文件：command + shift + . chmod 755 kspod 权限 ./kspod KSMallCartModule 1.0.0.0 ‘first commit’ pod ‘KSMallOrderModule’, :path =&gt; ‘../KSPrivatePods/KSMallOrderModule/‘ #订单模块 swift-alogrithm-club上的数据结构 Hexo博客地址 参考链接https://www.jianshu.com/p/860d3e0fff58https://segmentfault.com/a/1190000017986794 hexo n “我的博客” == hexo new “我的博客” //新建文章hexo g == hexo generate //生成hexo s == hexo server //启动服务预览hexo d == hexo deploy //部署 hexo server //Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s //静态模式hexo server -p 5000 //更改端口hexo server -i 192.168.1.1 //自定义 IPhexo clean //清除缓存，若是网页正常情况下可以忽略这条命令 部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。hexo clean 部署上传hexo g -d Podpod install –repo-update 更新慢的问题：无论是执行pod install还是pod update都卡在了Analyzing dependencies不动: pod install –verbose –no-repo-update pod update –verbose –no-repo-update 查找一个文件或目录find / -name validator.rb pod检查当前安装版本列表gem list –local | grep cocoapods卸载不用的版本sudo gem uninstall cocoapods 1.5.3安装指定版本sudo gem install cocoapods -v 1.6.1安装最新版本sudo gem install cocoapods Pod私有库制作教程http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/ ####gems目录cd /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.8.4 私有库i386上传问题，修改validator.rb文件 1def xcodebuild(action, scheme, configuration)2 require &#39;fourflusher&#39;3 command &#x3D; %W(clean #&#123;action&#125; -workspace #&#123;File.join(validation_dir, &#39;App.xcworkspace&#39;)&#125; -scheme #&#123;scheme&#125; -configuration #&#123;configuration&#125;)4 case consumer.platform_name5 when :osx, :macos6 command +&#x3D; %w(CODE_SIGN_IDENTITY&#x3D;)7 when :ios8# command +&#x3D; %w(CODE_SIGN_IDENTITY&#x3D;- -sdk iphonesimulator)9# command +&#x3D; Fourflusher::SimControl.new.destination(:oldest, &#39;iOS&#39;, deployment_target)10# xcconfig &#x3D; consumer.pod_target_xcconfig11# if xcconfig12# archs &#x3D; xcconfig[&#39;VALID_ARCHS&#39;]13# if archs &amp;&amp; (archs.include? &#39;armv7&#39;) &amp;&amp; !(archs.include? &#39;i386&#39;) &amp;&amp; (archs.include? &#39;x86_64&#39;)14# # Prevent Xcodebuild from testing the non-existent i386 simulator if armv7 is specified without i38615# command +&#x3D; %w(ARCHS&#x3D;x86_64)16# end17# end18 command +&#x3D; %w(--help)19 when :watchos 图片资源https://www.pexels.com/search/cat/ 1.48K张https://unsplash.com/search/photos/cat 3.9K张https://pixabay.com/zh/images/search/cat/ objc源码：https://opensource.apple.com/tarballs/objc4/https://objccn.io Flutter：https://flutterawesome.comhttps://flutter-io.cn/ 同步官网文档https://book.flutterchina.club flutter开发实战https://startflutter.com Swift：https://docs.swift.org/swift-book/LanguageGuide/TheBasics.htmlhttps://swiftgg.gitbook.io/swift/ RXSwift:https://beeth0ven.github.io/RxSwift-Chinese-Documentation/https://mcxiaoke.gitbooks.io/rxdocs/content/ 想看的书📚《结构化思维》《时间与任务管理》《有效沟通六要素》《可复制的领导力》","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"统一建模语言(UML)简介","slug":"统一建模语言-UML-简介","date":"2019-12-06T13:02:23.000Z","updated":"2020-03-23T06:40:11.159Z","comments":true,"path":"2019/12-06-23:00:01/","link":"","permalink":"http://yoursite.com/2019/12-06-23:00:01/","excerpt":"统一建模语言简介","text":"统一建模语言简介 统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。 统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。 UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。 这里主要介绍软件设计模式中经常用到的类图，以及类之间的关系。 类、接口1. 类类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。(1) 类名（Name）是一个字符串，例如，Student。(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示： 1[可见性]属性名:类型[&#x3D;默认值] 2例如：-name:String Tips：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。省略这些修饰符表示具有package（包）级别的可见性。 (3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示： 1[可见性]名称(参数列表)[:返回类型] 2例如：+display():void。 图 1 所示是学生类的 UML 表示。 2.抽象类在类图中以斜体表示一个抽象类或者抽象操作，抽象类是不能实例化的，一般至少包含一个抽象操作。 3.接口接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。 图 2 所示是图形类接口的表示。 类之间的关系在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。 1. 依赖关系依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。 图 4 所示是人与手机的关系图，人通过手机的语音传送方法打电话。 2. 关联关系关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。 关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。 在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。 图 5 所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。 3. 聚合关系聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。 图 6 所示是大学和教师的关系图。 4. 组合关系组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。 在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。 图 7 所示是头和嘴的关系图。 5. 泛化（继承）关系泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类， 其类图如图 8 所示： 6. 实现关系实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具。其类图如图 9 所示：","categories":[],"tags":[{"name":"UML","slug":"UML","permalink":"http://yoursite.com/tags/UML/"}]},{"title":"六大设计原则","slug":"六大设计原则","date":"2019-12-06T07:11:26.000Z","updated":"2020-03-23T07:42:43.234Z","comments":true,"path":"2019/12-06-15:11:26/","link":"","permalink":"http://yoursite.com/2019/12-06-15:11:26/","excerpt":"1、单一职责原则","text":"1、单一职责原则 单一职责原则的英文名称是Single Responsibility Principle ，简称SRP。这个设计原则备受争议，只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的。 定义：There should never be more than one reason for a class to change. 应该有且仅有一个原因引起类的变更。 理解：不同的类具备不同的职责，各司其职。做系统设计时，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。 优点：类的复杂性降低，实现什么职责都有清晰明确的定义；可读性提高，复杂性降低，那当然可读性提高了；可维护性提高，可读性提高，那当然更容易维护了；变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 总结：一个类只承担一个职责。单一职责原则提出了一个编写程序的标准，用”职责“或”变化原因“来衡量接口或类设计得是否优良，但是”职责“和”变化原因“都是不可度量的，因项目而异，因环境而异。 2、里氏替换原则它有两种定义：第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.(如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。) 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.(所有引用基类的地方必须能透明地使用其子类的对象。) 第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适用。 理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。 总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。 3、依赖倒置原则依赖倒置原则（Dependence Inversion Principle, DIP） 定义：High level modules should not depends upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 理解：1.高层模块不应该依赖低层模块，两者都应该依赖其抽象； 2.抽象不应该依赖细节； 3.细节应该依赖抽象。 应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。 总结：面向接口编程，提取出事务的本质和共性。 4、接口隔离原则什么是接口呢？它分为两种：实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的描述，这是一种接口。比如你定义Person这个类，然后使用Person zhangSan =new Person()产生了一个实例，这个实例要遵从的标准就是Person这个类，Person类就是zhangSan的接口。Java中的类也是一种接口。 类接口（Class Interface），Java中经常使用的interface关键字定义的接口。 什么是隔离呢？它有两种定义：Clients should not be forced to depend upon interfaces that they don’t use.(客户端不应该依赖它不需要的接口。)The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应该建立在最小的接口上。) 理解：第一种定义：”客户端不应该依赖不需要的接口“，那依赖什么？依赖它需要的接口，客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，那就需要对接口进行细化，保证其纯洁性；再看第二种定义：”类间的依赖关系应该建立在最小的接口“，它要求是最小的接口，也是要求接口细化，接口纯洁，与第一个定义如出一辙，只是一个事物的两种不同描述。我们可以把两个定义概括为一句话：建立单一接口，不用建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少。 总结：一个接口只服务于一个子模块或业务逻辑；通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到”满身筋骨肉“，而不是”肥嘟嘟“的一大堆方法；已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！ 5、迪米特法则迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道的最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。 理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。 总结：一定要做到：低耦合、高内聚。 6、开闭原则定义：Software entities like classes,modules and functions should be open for extension but closed for modifications.(一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。) 理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。 总结：对软件实体的改动，最好用扩展而非修改的方式。","categories":[{"name":"编程思想","slug":"编程思想","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"iOS资料整理","slug":"iOS资料整理","date":"2019-12-03T07:15:15.000Z","updated":"2020-05-23T08:22:27.265Z","comments":true,"path":"2019/12-03-15:15:15/","link":"","permalink":"http://yoursite.com/2019/12-03-15:15:15/","excerpt":"传送门","text":"传送门 新浪微博iOS客户端架构与优化之路MVVM实践干货 猿题库iOS客户端架构设计Pod私有库制作教程","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"资料整理","slug":"资料整理","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"}]}]}