{"meta":{"title":"X的博客","subtitle":"","description":"","author":"X","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"UI组件化方案设计","slug":"UI组件化方案设计","date":"2021-03-15T04:51:47.911Z","updated":"2021-03-15T05:27:20.853Z","comments":true,"path":"2021/Mon Mar 15 2021 12:51:47 GMT+0800 (中国标准时间)/","link":"","permalink":"http://yoursite.com/2021/Mon%20Mar%2015%202021%2012:51:47%20GMT+0800%20(%E4%B8%AD%E5%9B%BD%E6%A0%87%E5%87%86%E6%97%B6%E9%97%B4)/","excerpt":"1. 背景","text":"1. 背景 1.1 现状与问题目前咱们已经上线的移动端项目有凯叔讲故事、凯叔学堂、凯叔绘本识字，未来贯彻公司App矩阵化战略将会有更多的App项目诞生，面对繁重的需求是必然的，在人员数量不变的情况下这对每个团队的战斗输出能力有了更高的要求，采用合理化的方案提高人效尤为关键。很多技术同学都知道，移动端往往比较侧重业务开发，这会导致人员规模不断扩大，项目复杂度也会持续增长。而为了满足业务的快速上线，很难去落实统一的设计规范，在开发过程中由于UI缺乏标准导致的问题不断凸显，具体体现在以下4个层面： 设计层面：由于UI缺乏标准化设计规范，在不同App及不同开发平台上设计风格不统一，用户体验不一致；设计资源与代码均缺乏统一管理手段，无法实现积累沉淀，无法适应新业务的开发需求。 开发层面：组件代码实现碎片化，存在多次反复开发的情况，质量难以保证；各端代码API不统一，维护拓展成本较高。 测试层面：重复走查，频繁回归，每次发版均需验证项目不同页面的质量。 产品层面：版本迭代效率低，版本需求吞吐量低，不具备业务的快速拓展能力。 开发同学拿到设计稿进行视觉还原后，需要修改多次，才能最终通过设计师的验证，极大影响了开发效率，还降低了需求吞吐率。 1.2 目前移动端UI一致性情况目前**凯叔讲故事**项目已经更新迭代到了6.20.0版本，**凯叔学堂**项目已经迭代到了2.5.0版本，**凯叔绘本识字**项目更新到了1.0.4版本，由于前期侧重需求的快速上线，设计层面缺乏标准化的严格规范约束，不同项目之间UI设计风格也不统一，每个版本的UI是否达标需要靠设计的同学反复走查验收，开发同学反复的修改，耗费了较多的时间在这个上面，在开发过程中由于代码碎片化等问题也存在多次开发的情况，目前的维护成本较高。 我们来一下Teambition上面不同项目选取三个版本的UI问题所占bug率：凯叔讲故事（6.19.6，6.19.5，6.19.0）： 凯叔讲学堂（2.5.0，2.3.0，2.2.0）： 凯叔绘本识字（1.0.0，1.0.3，1.0.4）： 在Teambition中，三个项目选取三个版本UI适配问题占比超过总Bug数的12.83%，亟待优化；交互适配问题在绝大多数版本中均有出现，一定程度上反映了其发生的普遍性。 项目 凯叔讲故事 凯叔学堂 凯叔绘本识字 平均 UI适配问题占比(%) 15.7% 8.9% 13.9% 12.83% 2. 目标基于上述开发工作中的切实痛点，以及未来可预见的移动端能力需求，迫切需要一套统一的UI设计规范，以此沉淀设计风格，建立统一的UI设计标准。 UI组件化方案不同部门分工和协助关系： 设计师逐步沉淀为设计规范（包括组件、颜色、字体、图片等）上传至蓝湖供整个设计团队查阅，同时将其量化成Sketch插件；开发同学则将其代码化，针对Android、iOS进行组件库开发。 绘制完成的设计稿上传至蓝湖平台，交付开发同学进行设计稿还原。开发同学拿到设计稿后，就可以知道本次需求哪些组件已内置于代码组件库中，并可以点击设计稿中的链接，直接查看组件的使用说明。 3. 受众虽然UI组件化在落地上会增加开发和设计同学不少的工作量，推进组件化建设也是一个艰难的工作，由于成本也比较高，且无法量化评估收益，很多团队最终未达到预期效果，但一旦有效运作起来后，团队将获得丰厚的回报。 产品层面：UI组件运作起来后可使版本迭代效率增高，版本需求吞吐量提升，可在一定程度上获取业务的快速拓展能力。 设计层面：由于UI制度了标准化设计规范，在不同App及不同开发平台上设计风格也得到了统一，用户体验可以保持一致；每次项目的迭代中可以直接从现有组件库中挑选不同的组件来完成页面的设计，不需要每次设计和制作新的设计稿，在达到视觉体验标准的前提下也可以节省反复的UI验收时间。 开发层面：开发可以从组件库中选择相应的组件，避免多次反复开发的情况，质量难以保证的同时也可以提升效率，面对繁重的开发的任务也可以从容面对了。 测试层面：可以避免重复走查，频繁回归，不需要每次发版均需验证不同项目不同页面的质量，有效的提升了效率。 对公司移动端项目除了现有的凯叔讲故事、凯叔学堂、凯叔绘本识字能够使用到组件库中的组件，未来App矩阵化中的每个项目都能够享受到UI组件化带来的收益，提升每个团队和个人的效率，减轻因繁重的任务带来的压力。 由于组件库中的组件职责单一，降低了系统的耦合度，开发人员可以很容易地了解该组件提供的能力。组件可以自由替换、组合为高阶组件，在进行组件更新时仅需修改一处。每个项目成员维护一定数量的组件，让团队中每个人都能发挥所长，可以最大化团队的开发效率。 4. 组件化技术方案UI组件化基本架构图 系统底层库：这一层依赖的是系统的UIKit库，上层的基础控件层都是基于UIKit中的相关UI控件进行的个性化和可扩展化的封装。 中台基础控件层：这一层的基础控件都是继承自UIKit中的控件，对一些特殊的控件采用简单工厂的设计模式进行封装，支持快速创建、参数配置、样式选择等，具备拓展性。 中台组件层：这一层是由不同的基础控件进行的组合封装形成的基础组件，不同的基础组件可以组合形成业务组件，不同的业务组件可以组合形成业务模板。这一层的组件具备一定的可配置属性用于提升适用场景。可配置属性体现在三个方面：组件支持局部元素展示隐藏，例如商品卡片的标题、说明、价格可根据接口数据控制展示逻辑；组件支持多种样式，例如商品卡片的左图右文排列、上图下文排列；组件支持业务方配置主题，如调整高亮色、调整对齐方式等。 业务接口层：这一层提供给业务方使用，业务方只需要关心业务层的接口来创建和配置自己想要的UI组件，根据设计稿上标注的组件编号来选择对应的UI组件对象，最终构建成一个页面。 以设计师给出的audio_01组件为例，设计图如下： 这种在列表中展示多个Item的考虑业务的方便使用进行特殊的处理，通过组件内部定义常量来达到设计所要的效果，业务使用该组件的时候只能使用组件内部定义的常量来控制间距。如下图所示： 组件代码的实现UML类图如下：","categories":[{"name":"UI组件化","slug":"UI组件化","permalink":"http://yoursite.com/categories/UI%E7%BB%84%E4%BB%B6%E5%8C%96/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"AFNetworking源码剖析（三）","slug":"AFNetworking源码剖析（三）","date":"2021-02-25T11:15:48.000Z","updated":"2021-02-25T12:58:36.677Z","comments":true,"path":"2021/2021-02-25-19:15:48/","link":"","permalink":"http://yoursite.com/2021/2021-02-25-19:15:48/","excerpt":"目录","text":"目录 AFSecurityPolic http，https介绍 http缺点与加密 https通讯步骤 自签证书AF处理 AFSecurityPolic源码分析 AFNetworkReachabilityManager+图片管理 AFNetworkReachabilityManager iPhone网络bug AFAutoPurgingImageCache AFImageDownloader 其他框架对图片处理 UIKit（AFNetworking）","categories":[{"name":"AFN","slug":"AFN","permalink":"http://yoursite.com/categories/AFN/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"AFNetworking源码剖析（二）","slug":"AFNetworking源码剖析（二）","date":"2021-01-27T06:37:33.000Z","updated":"2021-02-25T11:16:55.744Z","comments":true,"path":"2021/2021-01-27-14:37:33/","link":"","permalink":"http://yoursite.com/2021/2021-01-27-14:37:33/","excerpt":"目录","text":"目录 NSCopying，NSObject，NSCoding协议 contentType初识 多表单对数据的封装 stream的调用 关系解说 AFURLResponseSerializer 一、NSCopying，NSObject，NSCoding协议介绍我们发现AFURLRequestSerialization遵循了NSCopying，NSObject，NSSecureCoding三个协议： 1&#x2F;*2NSObject：oc对象的基本行为3NSCodding，NSSecureCoding：存储数据，编解码4NSCopying：可以自定的类支出拷贝的功能5*&#x2F;6@protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;7 8&#x2F;**9 Returns a request with the specified parameters encoded into a copy of the original request.1011 @param request The original request.12 @param parameters The parameters to be encoded.13 @param error The error that occurred while attempting to encode the request parameters.1415 @return A serialized request.16 *&#x2F;17- (nullable NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request18 withParameters:(nullable id)parameters19 error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;2021@end NSObject协议，包含了NSObject相关的抽象，都是我们平常会使用到的一些方法。详细讲解可参考 NSObject协议 NSCoding 是把数据存储在iOS和Mac OS上的一种极其简单和方便的方式，把模型对象直接转变成一个文件，然后再把文件重新加载到内存里，并不需要任何文件解析和序列化的逻辑。通过扩展你的数据类来支持encode 和 decode 功能就可以了。 NSSecureCoding：使用NSCoding来读写用户数据文件的问题在于，把全部的类编码到一个文件里，也就意味着给了这个 文件访问你APP里面实例类的权限。 NSSecureCoding除了在解码时要指定key和要解码的对象的类，如果要求的类和从文件中解码出的对 象的类不匹配，NSCoder会抛出异常，代表数据已经被篡改了。符合NSSecureCoding 协议并重写了-initWithCoder 的类应该使用 -decodeObjectOfClass:forKey:而不是 -decodeObjectForKey: 详细可参考 AFNetworking 知识点1–NSCoding NSSecureCoding 使用对象时经常需要拷贝它。在Objective-C中，此操作通过copy方法完成。如果想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法: 1- (id)copyWithZone:(NSZone *)zone 详细了解可以参考 理解NSCopying协议 二、contentType初识enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。默认地，表单数据会编码为 “application/x-www-form-urlencoded”。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值）。 enctype属性值 值 描述 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 text/plain 空格转换为 “+” 加号，但不对特殊字符编码。 详细介绍参考 post请求头中常见content-type（非常重要） 三、多表单对数据的封装多表单流程图： 多表单结构图： 多表单数据详细拼接： NSIInputStream 和 NSOutputStream 四、stream的调用先看AFURLRequestSerialization中request的设置： 1- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123;2 if ([self.bodyStream isEmpty]) &#123;3 return self.request;4 &#125;56 &#x2F;&#x2F; Reset the initial and final boundaries to ensure correct Content-Length7 [self.bodyStream setInitialAndFinalBoundaries];8 [self.request setHTTPBodyStream:self.bodyStream];910 [self.request setValue:[NSString stringWithFormat:@&quot;multipart&#x2F;form-data; boundary&#x3D;%@&quot;, self.boundary] forHTTPHeaderField:@&quot;Content-Type&quot;];11 [self.request setValue:[NSString stringWithFormat:@&quot;%llu&quot;, [self.bodyStream contentLength]] forHTTPHeaderField:@&quot;Content-Length&quot;];1213 return self.request;14&#125; 通过看setHTTPBodyStream官方描述，HTTPBody和HTTPBodyStream是互斥的 1&#x2F;*!2 @abstract Sets the request body data of the receiver.3 @discussion This data is sent as the message body of the request, as4 in done in an HTTP POST request.5*&#x2F;6@property (nullable, copy) NSData *HTTPBody;78&#x2F;*!9 @abstract Sets the request body to be the contents of the given stream. 10 @discussion The provided stream should be unopened; the request will take11 over the stream&#39;s delegate. The entire stream&#39;s contents will be 12 transmitted as the HTTP body of the request. Note that the body stream13 and the body data (set by setHTTPBody:, above) are mutually exclusive 14 - setting one will clear the other.15*&#x2F;16@property (nullable, retain) NSInputStream *HTTPBodyStream; 读取Stream的长度 1#pragma mark - NSInputStream23- (NSInteger)read:(uint8_t *)buffer4 maxLength:(NSUInteger)length5&#123;6 if ([self streamStatus] &#x3D;&#x3D; NSStreamStatusClosed) &#123;7 return 0;8 &#125;910 NSInteger totalNumberOfBytesRead &#x3D; 0;1112 &#x2F;&#x2F;&#x2F;length在mac 64上为3276813 &#x2F;&#x2F;&#x2F;每次读取32768的大小14 while ((NSUInteger)totalNumberOfBytesRead &lt; MIN(length, self.numberOfBytesInPacket)) &#123;15 &#x2F;&#x2F;&#x2F;如果当前读取的body不存在或者body没有可读字节16 if (!self.currentHTTPBodyPart || ![self.currentHTTPBodyPart hasBytesAvailable]) &#123;17 &#x2F;&#x2F;&#x2F;把下一个body赋值给当前的body ， 如果下一个为nil 就退出循环18 if (!(self.currentHTTPBodyPart &#x3D; [self.HTTPBodyPartEnumerator nextObject])) &#123;19 break;20 &#125;21 &#125; else &#123;22 &#x2F;&#x2F;&#x2F;当前body存在 且没有读完 且读取长度还小于3276823 &#x2F;&#x2F;&#x2F;剩余可读文件的大小24 NSUInteger maxLength &#x3D; MIN(length, self.numberOfBytesInPacket) - (NSUInteger)totalNumberOfBytesRead;25 &#x2F;&#x2F;&#x2F;调用bodyparrt的接口26 &#x2F;&#x2F;&#x2F;self.HTTPBodyParts --&gt; bodyPart27 NSInteger numberOfBytesRead &#x3D; [self.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength];28 if (numberOfBytesRead &#x3D;&#x3D; -1) &#123;29 self.streamError &#x3D; self.currentHTTPBodyPart.inputStream.streamError;30 break;31 &#125; else &#123;32 &#x2F;&#x2F;&#x2F;当前总大小33 totalNumberOfBytesRead +&#x3D; numberOfBytesRead;3435 &#x2F;&#x2F;&#x2F;延迟36 if (self.delay &gt; 0.0f) &#123;37 [NSThread sleepForTimeInterval:self.delay];38 &#125;39 &#125;40 &#125;41 &#125;4243 return totalNumberOfBytesRead;44&#125; 开流 1@implementation AFHTTPBodyPart23- (instancetype)init &#123;4 self &#x3D; [super init];5 if (!self) &#123;6 return nil;7 &#125;89 [self transitionToNextPhase];1011 return self;12&#125;1314&#x2F;&#x2F;&#x2F;一步步改状态15- (BOOL)transitionToNextPhase &#123;16 if (![[NSThread currentThread] isMainThread]) &#123;17 dispatch_sync(dispatch_get_main_queue(), ^&#123;18 [self transitionToNextPhase];19 &#125;);20 return YES;21 &#125;2223 switch (_phase) &#123;24 case AFEncapsulationBoundaryPhase:25 _phase &#x3D; AFHeaderPhase;26 break;27 case AFHeaderPhase:28 [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];29 [self.inputStream open];30 _phase &#x3D; AFBodyPhase;31 break;32 case AFBodyPhase:33 [self.inputStream close];34 _phase &#x3D; AFFinalBoundaryPhase;35 break;36 case AFFinalBoundaryPhase:37 default:38 _phase &#x3D; AFEncapsulationBoundaryPhase;39 break;40 &#125;41 _phaseReadOffset &#x3D; 0;4243 return YES;44&#125; 五、AFURLResponseSerializerAFURLSessionManager请求成功后的逻辑： 1&#x2F;&#x2F;&#x2F;请求成功，为什么要异步？2&#x2F;&#x2F;&#x2F;因为response 序列化 200 300 400 500 json -&gt; dict model 等处理起来相对比较耗时，会阻塞主线程3dispatch_async(url_session_manager_processing_queue(), ^&#123;4 NSError *serializationError &#x3D; nil;5 &#x2F;&#x2F;&#x2F;根据对应的task和data将response data解析成可用的数据格式， 比如JSON seriallizer就将data解析成JSON格式6 responseObject &#x3D; [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];7 &#x2F;&#x2F;&#x2F;注意如果有downloadFileURL，意味着data存放在了磁盘上了，所以此处responseObject保存的是data存放位置，供后面completionHandler处理。没有downloadFileURL，就直接使用内存中的解析后的data数据8 if (self.downloadFileURL) &#123;9 responseObject &#x3D; self.downloadFileURL;10 &#125;1112 if (responseObject) &#123;13 userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] &#x3D; responseObject;14 &#125;1516 if (serializationError) &#123;17 userInfo[AFNetworkingTaskDidCompleteErrorKey] &#x3D; serializationError;18 &#125;1920 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;21 if (self.completionHandler) &#123;22 self.completionHandler(task.response, responseObject, serializationError);23 &#125;2425 dispatch_async(dispatch_get_main_queue(), ^&#123;26 [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];27 &#125;);28 &#125;);29&#125;); AFURLResponseSerialization这里可以发现removesKeysWithNullValues这个属性设置为YES能够过滤NSNull空值 1#pragma mark - AFURLResponseSerialization23&#x2F;**4 Whether to remove keys with &#96;NSNull&#96; values from response JSON. Defaults to &#96;NO&#96;.5 *&#x2F;6@property (nonatomic, assign) BOOL removesKeysWithNullValues;78- (id)responseObjectForResponse:(NSURLResponse *)response9 data:(NSData *)data10 error:(NSError *__autoreleasing *)error11&#123;12 if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;13 if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;14 return nil;15 &#125;16 &#125;1718 &#x2F;&#x2F; Workaround for behavior of Rails to return a single space for &#96;head :ok&#96; (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.19 &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;rails&#x2F;rails&#x2F;issues&#x2F;174220 BOOL isSpace &#x3D; [data isEqualToData:[NSData dataWithBytes:&quot; &quot; length:1]];21 22 if (data.length &#x3D;&#x3D; 0 || isSpace) &#123;23 return nil;24 &#125;25 26 NSError *serializationError &#x3D; nil;27 28 id responseObject &#x3D; [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];2930 if (!responseObject)31 &#123;32 if (error) &#123;33 *error &#x3D; AFErrorWithUnderlyingError(serializationError, *error);34 &#125;35 return nil;36 &#125;37 38 if (self.removesKeysWithNullValues) &#123;39 return AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);40 &#125;4142 return responseObject;43&#125;","categories":[{"name":"AFN","slug":"AFN","permalink":"http://yoursite.com/categories/AFN/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"AFNetworking源码剖析（一）","slug":"AFNetworking源码剖析（一）","date":"2021-01-14T01:33:51.000Z","updated":"2021-01-29T09:45:17.058Z","comments":true,"path":"2021/2021-01-14-09:33:51/","link":"","permalink":"http://yoursite.com/2021/2021-01-14-09:33:51/","excerpt":"目录","text":"目录 AFN框架结构 manager初始化 request方法封装 manager，task与delegate（代理）的关系 - 重点 task的resume和suspend的处理 一、AFN框架结构 二、NSURLSession流程 AFHTTPSessionManaer -&gt; AFURLSessionManager 初始化AFHTTPSessionManaer 继承 AFURLSessionManager manager设计模式：采用的工厂设计模式； 线程 –2.0版本 AF采用常驻线程， –3.0后版本采用 NSOperationQueue 看一下AFHTTPSessionManaer构造方法： 1- (instancetype)initWithBaseURL:(NSURL *)url2 sessionConfiguration:(NSURLSessionConfiguration *)configuration3&#123;4 self &#x3D; [super initWithSessionConfiguration:configuration];5 if (!self) &#123;6 return nil;7 &#125;89 &#x2F;&#x2F; Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected10 if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;&#x2F;&quot;]) &#123;11 url &#x3D; [url URLByAppendingPathComponent:@&quot;&quot;];12 &#125;1314 self.baseURL &#x3D; url;1516 self.requestSerializer &#x3D; [AFHTTPRequestSerializer serializer];17 self.responseSerializer &#x3D; [AFJSONResponseSerializer serializer];1819 return self;20&#125; Ensure terminal slash for baseURL path, so that NSURL+URLWithString:relativeToURL: works as expected为了确保NSURL+URLWithString:relativeToURL: works可以正确执行，在baseURL path的最后添加’/‘url有值且最后没有’/‘，那么在url的末尾添加’/‘ 不带’/‘，会有个默认重定向， –www.baidu.com 会请求2次 浪费带宽 表示目录，信息的拼接，路由， username=zhangsan —request 封装 SEO 搜索引擎优化 看一下调用的super initWithSessionConfiguration:configuration方法实现：查看里面的代码注释 1- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;2 self &#x3D; [super init];3 if (!self) &#123;4 return nil;5 &#125;67 &#x2F;&#x2F;&#x2F;设置默认的configuration，配置session8 if (!configuration) &#123;9 configuration &#x3D; [NSURLSessionConfiguration defaultSessionConfiguration];10 &#125;1112 &#x2F;&#x2F;&#x2F;持有configuration13 self.sessionConfiguration &#x3D; configuration;1415 &#x2F;&#x2F;&#x2F;创建session 串行：多个task16 &#x2F;&#x2F;&#x2F;设置为delegate的操作队列并发的线程数量1，也就是串行队列17 self.operationQueue &#x3D; [[NSOperationQueue alloc] init];18 &#x2F;&#x2F;&#x2F;保证线程安全，&#96;[NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]&#96; 方法中官方有写明要求：The queue should be a serial queue19 self.operationQueue.maxConcurrentOperationCount &#x3D; 1;202122 &#x2F;*23 -如果完成后需要做复杂（耗时）的处理，可以选择异步队列24 -如果完成后直接更新UI，可以选择主队列25 [NSOperationQueue mainQueue]26 *&#x2F;27 28 &#x2F;&#x2F;&#x2F;默认为json解析29 self.responseSerializer &#x3D; [AFJSONResponseSerializer serializer];3031 &#x2F;&#x2F;&#x2F;设置默认证书 无条件信任证书https认证 --自签证书 如何处理？ - CA -https32 self.securityPolicy &#x3D; [AFSecurityPolicy defaultPolicy];3334#if !TARGET_OS_WATCH35 &#x2F;&#x2F;&#x2F;网络状态监听36 self.reachabilityManager &#x3D; [AFNetworkReachabilityManager sharedManager];37#endif3839 &#x2F;&#x2F;&#x2F;为什么要收集： cancel resume supend： task ： id40 &#x2F;&#x2F;&#x2F;delegate&#x3D; value taskid &#x3D; key41 self.mutableTaskDelegatesKeyedByTaskIdentifier &#x3D; [[NSMutableDictionary alloc] init];4243 &#x2F;&#x2F;&#x2F;使用NSLock确保线程安全44 self.lock &#x3D; [[NSLock alloc] init];45 self.lock.name &#x3D; AFURLSessionManagerLockName;4647 &#x2F;&#x2F;&#x2F;异步获取当前session的所有未完成的task，其实讲道理来说在初始化中调用这个方法应该里面一个task都不会有48 &#x2F;&#x2F;&#x2F;background后台任务重新回来初始化session，可能会有先前的任务49 &#x2F;&#x2F;&#x2F;https:&#x2F;&#x2F;github.com&#x2F;AFNetworking&#x2F;AFNetworking&#x2F;issues&#x2F;349950 [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;51 for (NSURLSessionDataTask *task in dataTasks) &#123;52 [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];53 &#125;5455 for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;56 [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];57 &#125;5859 for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;60 [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];61 &#125;62 &#125;];6364 return self;65&#125; 请求头封装比如我们平时发起一个请求，找到NSURLRequest构造方法： 1- (NSMutableURLRequest *)requestWithMethod:(NSString *)method2 URLString:(NSString *)URLString3 parameters:(id)parameters4 error:(NSError *__autoreleasing *)error5&#123;6 NSParameterAssert(method);7 NSParameterAssert(URLString);89 NSURL *url &#x3D; [NSURL URLWithString:URLString];1011 NSParameterAssert(url);1213 NSMutableURLRequest *mutableRequest &#x3D; [[NSMutableURLRequest alloc] initWithURL:url];14 &#x2F;&#x2F;&#x2F;设置请求方式（get、post、put...）15 mutableRequest.HTTPMethod &#x3D; method;1617 &#x2F;&#x2F;&#x2F;将request的各种属性遍历，给NSMutableURLRequest自带的相关属性赋值18 for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;19 &#x2F;&#x2F;&#x2F;给设置过的属性，添加到request （如：timeout）20 if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;21 &#x2F;&#x2F;&#x2F;通过kvc动态的给mutableRequest添加value22 [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];23 &#125;24 &#125;2526&#x2F;&#x2F;&#x2F; get post paraments27&#x2F;&#x2F;&#x2F;将传入的参数进行编码，拼接到url后并返回 count&#x3D;5&amp;start&#x3D;128 mutableRequest &#x3D; [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];2930 return mutableRequest;31&#125; 相关的KeyPaths 1static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123;2 static NSArray *_AFHTTPRequestSerializerObservedKeyPaths &#x3D; nil;3 static dispatch_once_t onceToken;4 dispatch_once(&amp;onceToken, ^&#123;5 _AFHTTPRequestSerializerObservedKeyPaths &#x3D; @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];6 &#125;);78 return _AFHTTPRequestSerializerObservedKeyPaths;9&#125; 给这些keyPath添加上观察者 1self.mutableObservedChangedKeyPaths &#x3D; [NSMutableSet set];2for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;3 if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123;4 [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];5 &#125;6&#125; 监听并添加到self.mutableObservedChangedKeyPaths集合中 1#pragma mark - NSKeyValueObserving2- (void)observeValueForKeyPath:(NSString *)keyPath3 ofObject:(__unused id)object4 change:(NSDictionary *)change5 context:(void *)context6&#123;7 if (context &#x3D;&#x3D; AFHTTPRequestSerializerObserverContext) &#123;8 if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &#123;9 [self.mutableObservedChangedKeyPaths removeObject:keyPath];10 &#125; else &#123;11 [self.mutableObservedChangedKeyPaths addObject:keyPath];12 &#125;13 &#125;14&#125; 注意这些keypath是关闭了自动监听的，采用在set方法中手动调用的方式 1+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;2 if ([AFHTTPRequestSerializerObservedKeyPaths() containsObject:key]) &#123;3 return NO;4 &#125;56 return [super automaticallyNotifiesObserversForKey:key];7&#125;89&#x2F;&#x2F; Workarounds for crashing behavior using Key-Value Observing with XCTest10&#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;AFNetworking&#x2F;AFNetworking&#x2F;issues&#x2F;25231112- (void)setAllowsCellularAccess:(BOOL)allowsCellularAccess &#123;13 [self willChangeValueForKey:NSStringFromSelector(@selector(allowsCellularAccess))];14 _allowsCellularAccess &#x3D; allowsCellularAccess;15 [self didChangeValueForKey:NSStringFromSelector(@selector(allowsCellularAccess))];16&#125;1718- (void)setCachePolicy:(NSURLRequestCachePolicy)cachePolicy &#123;19 [self willChangeValueForKey:NSStringFromSelector(@selector(cachePolicy))];20 _cachePolicy &#x3D; cachePolicy;21 [self didChangeValueForKey:NSStringFromSelector(@selector(cachePolicy))];22&#125;2324- (void)setHTTPShouldHandleCookies:(BOOL)HTTPShouldHandleCookies &#123;25 [self willChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldHandleCookies))];26 _HTTPShouldHandleCookies &#x3D; HTTPShouldHandleCookies;27 [self didChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldHandleCookies))];28&#125;2930- (void)setHTTPShouldUsePipelining:(BOOL)HTTPShouldUsePipelining &#123;31 [self willChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldUsePipelining))];32 _HTTPShouldUsePipelining &#x3D; HTTPShouldUsePipelining;33 [self didChangeValueForKey:NSStringFromSelector(@selector(HTTPShouldUsePipelining))];34&#125;3536- (void)setNetworkServiceType:(NSURLRequestNetworkServiceType)networkServiceType &#123;37 [self willChangeValueForKey:NSStringFromSelector(@selector(networkServiceType))];38 _networkServiceType &#x3D; networkServiceType;39 [self didChangeValueForKey:NSStringFromSelector(@selector(networkServiceType))];40&#125;4142- (void)setTimeoutInterval:(NSTimeInterval)timeoutInterval &#123;43 [self willChangeValueForKey:NSStringFromSelector(@selector(timeoutInterval))];44 _timeoutInterval &#x3D; timeoutInterval;45 [self didChangeValueForKey:NSStringFromSelector(@selector(timeoutInterval))];46&#125; 请参数封装查看requestBySerializingRequest方法的实现： 1- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request2 withParameters:(id)parameters3 error:(NSError *__autoreleasing *)error4&#123;5 NSParameterAssert(request);67 NSMutableURLRequest *mutableRequest &#x3D; [request mutableCopy];89 &#x2F;&#x2F;&#x2F;给mutableRequest.headfidld赋值10 &#x2F;*11 1.请求行（状态行）：get，url，http协议1.112 2.请求头：content-type，Accept-Language，User-Agent13 3.请求体：get&#x2F;post get参数拼接在url后面，post数据放在body14 *&#x2F;15 &#x2F;&#x2F;&#x2F;head：配置 （允许蜂窝网络、超时设置等）16 &#x2F;&#x2F;&#x2F;http headers17 [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;18 if (![request valueForHTTPHeaderField:field]) &#123;19 [mutableRequest setValue:value forHTTPHeaderField:field];20 &#125;21 &#125;];2223 &#x2F;&#x2F;&#x2F;重点- query参数解析24 NSString *query &#x3D; nil;25 if (parameters) &#123;26 &#x2F;&#x2F;&#x2F;定义的解析方式27 &#x2F;&#x2F;&#x2F;复杂解析器28 &#x2F;&#x2F;&#x2F;JSON -- dic29 &#x2F;&#x2F;&#x2F;xml ---dic30 if (self.queryStringSerialization) &#123;31 NSError *serializationError;32 query &#x3D; self.queryStringSerialization(request, parameters, &amp;serializationError);33 34 if (serializationError) &#123;35 if (error) &#123;36 *error &#x3D; serializationError;37 &#125;3839 return nil;40 &#125;41 &#125; else &#123;42 &#x2F;&#x2F;&#x2F;默认解析方式，dic -&gt; count&#x3D;5&amp;start&#x3D;143 switch (self.queryStringSerializationStyle) &#123;44 case AFHTTPRequestQueryStringDefaultStyle:45 &#x2F;&#x2F;&#x2F;将parameters传入这个c行数46 query &#x3D; AFQueryStringFromParameters(parameters);47 break;48 &#125;49 &#125;50 &#125;5152 &#x2F;&#x2F;&#x2F;最后判断该request中是否包含了GET、HEAD、DELETE（都包含在self.HTTPMethodsEncodingParametersInURI中），因为这几个method的query是拼接到url后面的。而POST、PUT是把query拼接到http body中的。53 if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;54 if (query &amp;&amp; query.length &gt; 0) &#123;55 mutableRequest.URL &#x3D; [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];56 &#125;57 &#125; else &#123;58 &#x2F;&#x2F; #2864: an empty string is a valid x-www-form-urlencoded payload59 if (!query) &#123;60 query &#x3D; @&quot;&quot;;61 &#125;62 &#x2F;&#x2F;&#x2F;函数会判断request的Content-Type是否设置了，如果没有，就默认设置为application&#x2F;x-www-form-urlencoded63 &#x2F;&#x2F;&#x2F;application&#x2F;x-www-form-urlencoded是常用的表单发包方式，普通的表单提交，或者js发包，默认都是通过这种方式64 if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;65 [mutableRequest setValue:@&quot;application&#x2F;x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];66 &#125;67 &#x2F;&#x2F;&#x2F;设置请求体68 [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];69 &#125;7071 return mutableRequest;72&#125; 重点：处理query的几个C方法的实现： 1&#x2F;&#x2F;&#x2F;内部方法： C： OC --&gt; C2NSString * AFQueryStringFromParameters(NSDictionary *parameters) &#123;3 NSMutableArray *mutablePairs &#x3D; [NSMutableArray array];4 &#x2F;&#x2F;&#x2F;把参数传给AFQueryStringPairsFromDictionary，使用AFQueryStringPair对象处理成 username&#x3D;@&quot;xxx&quot;形式5 for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;6 &#x2F;&#x2F;&#x2F;百分号编码7 [mutablePairs addObject:[pair URLEncodedStringValue]];8 &#125;9 &#x2F;&#x2F;&#x2F;拆分拼接数组返回参数字符串10 return [mutablePairs componentsJoinedByString:@&quot;&amp;&quot;];11&#125;1213&#x2F;&#x2F;&#x2F;过渡14NSArray * AFQueryStringPairsFromDictionary(NSDictionary *dictionary) &#123;15 return AFQueryStringPairsFromKeyAndValue(nil, dictionary);16&#125;1718&#x2F;&#x2F;&#x2F;使用了递归19&#x2F;*20 接着会对value的类型进行判断，有NSDictionary、NSArray、NSSet类型。这是AFQueryStringPairsFromKeyAndValue的核心----递归调用并解析，你不能保证NSDictionary的value中存放的是什么类型21*&#x2F;22NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) &#123;23 NSMutableArray *mutableQueryStringComponents &#x3D; [NSMutableArray array];2425 &#x2F;&#x2F;&#x2F;使用NSSting的compare:函数来进行升序排列26 NSSortDescriptor *sortDescriptor &#x3D; [NSSortDescriptor sortDescriptorWithKey:@&quot;description&quot; ascending:YES selector:@selector(compare:)];2728 &#x2F;&#x2F;&#x2F;判断value是什么类型的，如何去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组（数组中是pair对象）返回29 if ([value isKindOfClass:[NSDictionary class]]) &#123;30 NSDictionary *dictionary &#x3D; value;31 &#x2F;&#x2F; Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries32 33 &#x2F;&#x2F;&#x2F; dict ---&gt; username&#x3D;@&quot;xxx&quot;&amp;password&#x3D;@&quot;123&quot;34 for (id nestedKey in [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;35 id nestedValue &#x3D; dictionary[nestedKey];36 if (nestedValue) &#123;37 [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [NSString stringWithFormat:@&quot;%@[%@]&quot;, key, nestedKey] : nestedKey), nestedValue)];38 &#125;39 &#125;40 &#125; else if ([value isKindOfClass:[NSArray class]]) &#123;41 NSArray *array &#x3D; value;42 for (id nestedValue in array) &#123;43 &#x2F;&#x2F;&#x2F;改进：[]加上nestedValue的下标，或者传入的Array等转成json字符串44 [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([NSString stringWithFormat:@&quot;%@[]&quot;, key], nestedValue)];45 &#125;46 &#125; else if ([value isKindOfClass:[NSSet class]]) &#123;47 NSSet *set &#x3D; value;48 for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;49 [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];50 &#125;51 &#125; else &#123;52 &#x2F;&#x2F;&#x2F;既然是递归，那么就要有结束递归的情况，比如解析到最后，对应value是一个NSString，那么就的调用函数中最后的else53 [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];54 &#125;5556 return mutableQueryStringComponents;57&#125; manager，task和代理的关系 先看一下self.session的get方法 1&#x2F;*2互斥锁优缺点3优点：能有效防止因多线程抢夺资源造成的数据安全问题4缺点：需要消耗大量cpu资源56互斥锁使用前提：多条线程抢夺同一块资源7总结8synchronized中传入的object的内存地址，被用作key，通过hash map对应的一个系统维护的递归锁。9如果object 被外部访问变化，则就失去了锁的作用。所以最好本类声明一个对象属性来当做key10*&#x2F;11- (NSURLSession *)session &#123;12 &#x2F;&#x2F;&#x2F;增加一个互斥锁，防止因多线程抢夺资源造成的数据安全13 @synchronized (self) &#123;14 if (!_session) &#123;15 _session &#x3D; [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];16 &#125;17 &#125;18 return _session;19&#125; 给dataTask添加delegate 1- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask2 uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock3 downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock4 completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler5&#123;6 &#x2F;&#x2F;&#x2F;创建临时变量，一个task对应一个delegate7 8 &#x2F;&#x2F;&#x2F;相互依赖关系 manager -&gt; session -&gt; task -&gt; delegate -&#x2F;weak&#x2F;-防止循环引用&gt; manager9 AFURLSessionManagerTaskDelegate *delegate &#x3D; [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];10 delegate.manager &#x3D; self;11 delegate.completionHandler &#x3D; completionHandler;1213 &#x2F;*14 task.taskIdentifier &#x3D; key delegate &#x3D; value，确保task唯一15 dataTask.taskDescription自行设置的，区分是否是当前的session创建的16 *&#x2F;17 dataTask.taskDescription &#x3D; self.taskDescriptionForSessionTasks;18 19 &#x2F;&#x2F;&#x2F;为什么关联在一起？20 [self setDelegate:delegate forTask:dataTask];2122 &#x2F;&#x2F;&#x2F;给对应的delegate设置上相关block回调23 delegate.uploadProgressBlock &#x3D; uploadProgressBlock;24 delegate.downloadProgressBlock &#x3D; downloadProgressBlock;25&#125; 给task设置关联的delegate，以task.taskIdentifier为key，delegate对象为value存到self.mutableTaskDelegatesKeyedByTaskIdentifier (NSMutableDictionary类型)中 1- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate2 forTask:(NSURLSessionTask *)task3&#123;4 NSParameterAssert(task);5 NSParameterAssert(delegate);6 7 &#x2F;&#x2F;&#x2F;加锁确保中间代码块是原子操作，线程安全8 [self.lock lock];9 &#x2F;&#x2F;&#x2F;将delegate存入字典，以taskid为key，说明每个task都有各自的代理10 self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] &#x3D; delegate;11 [self addNotificationObserverForTask:task];12 [self.lock unlock];13&#125; task的resume和suspend的处理回到我们dataTask初始化的地方： 1- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString2 parameters:(nullable id)parameters3 headers:(nullable NSDictionary &lt;NSString *, NSString *&gt; *)headers4 progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress5 success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success6 failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure7&#123;8 NSURLSessionDataTask *dataTask &#x3D; [self dataTaskWithHTTPMethod:@&quot;POST&quot; URLString:URLString parameters:parameters headers:headers uploadProgress:uploadProgress downloadProgress:nil success:success failure:failure];9 10 [dataTask resume];11 12 return dataTask;13&#125; 这个resume是有猫腻的，细心的我们发现AFN对resume，suspend方法进行了swizzle： 1+ (void)load &#123;2 &#x2F;**3 WARNING: Trouble Ahead4 https:&#x2F;&#x2F;github.com&#x2F;AFNetworking&#x2F;AFNetworking&#x2F;pull&#x2F;27025 *&#x2F;67 if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;8 &#x2F;**9 iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky.10 Many Unit Tests have been built to validate as much of this behavior has possible.11 Here is what we know:12 - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn&#39;t actually the type of class you will get back.13 - Simply referencing &#96;[NSURLSessionTask class]&#96; will not work. You need to ask an &#96;NSURLSession&#96; to actually create an object, and grab the class from there.14 - On iOS 7, &#96;localDataTask&#96; is a &#96;__NSCFLocalDataTask&#96;, which inherits from &#96;__NSCFLocalSessionTask&#96;, which inherits from &#96;__NSCFURLSessionTask&#96;.15 - On iOS 8, &#96;localDataTask&#96; is a &#96;__NSCFLocalDataTask&#96;, which inherits from &#96;__NSCFLocalSessionTask&#96;, which inherits from &#96;NSURLSessionTask&#96;.16 - On iOS 7, &#96;__NSCFLocalSessionTask&#96; and &#96;__NSCFURLSessionTask&#96; are the only two classes that have their own implementations of &#96;resume&#96; and &#96;suspend&#96;, and &#96;__NSCFLocalSessionTask&#96; DOES NOT CALL SUPER. This means both classes need to be swizzled.17 - On iOS 8, &#96;NSURLSessionTask&#96; is the only class that implements &#96;resume&#96; and &#96;suspend&#96;. This means this is the only class that needs to be swizzled.18 - Because &#96;NSURLSessionTask&#96; is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there.19 20 Some Assumptions:21 - No implementations of &#96;resume&#96; or &#96;suspend&#96; call super. If this were to change in a future version of iOS, we&#39;d need to handle it.22 - No background task classes override &#96;resume&#96; or &#96;suspend&#96;23 24 The current solution:25 1) Grab an instance of &#96;__NSCFLocalDataTask&#96; by asking an instance of &#96;NSURLSession&#96; for a data task.26 2) Grab a pointer to the original implementation of &#96;af_resume&#96;27 3) Check to see if the current class has an implementation of resume. If so, continue to step 4.28 4) Grab the super class of the current class.29 5) Grab a pointer for the current class to the current implementation of &#96;resume&#96;.30 6) Grab a pointer for the super class to the current implementation of &#96;resume&#96;.31 7) If the current class implementation of &#96;resume&#96; is not equal to the super class implementation of &#96;resume&#96; AND the current implementation of &#96;resume&#96; is not equal to the original implementation of &#96;af_resume&#96;, THEN swizzle the methods32 8) Set the current class to the super class, and repeat steps 3-833 *&#x2F;34 NSURLSessionConfiguration *configuration &#x3D; [NSURLSessionConfiguration ephemeralSessionConfiguration];35 NSURLSession *session &#x3D; [NSURLSession sessionWithConfiguration:configuration];36#pragma GCC diagnostic push37#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;38 NSURLSessionDataTask *localDataTask &#x3D; [session dataTaskWithURL:nil];39#pragma clang diagnostic pop40 IMP originalAFResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));41 Class currentClass &#x3D; [localDataTask class];42 43 &#x2F;&#x2F;&#x2F; 保证只交换一次44 while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;45 Class superClass &#x3D; [currentClass superclass];46 IMP classResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));47 IMP superclassResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));48 if (classResumeIMP !&#x3D; superclassResumeIMP &amp;&amp;49 originalAFResumeIMP !&#x3D; classResumeIMP) &#123;50 [self swizzleResumeAndSuspendMethodForClass:currentClass];51 &#125;52 currentClass &#x3D; [currentClass superclass];53 &#125;54 55 [localDataTask cancel];56 [session finishTasksAndInvalidate];57 &#125;58&#125;5960+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;61 Method afResumeMethod &#x3D; class_getInstanceMethod(self, @selector(af_resume));62 Method afSuspendMethod &#x3D; class_getInstanceMethod(self, @selector(af_suspend));6364 if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;65 af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));66 &#125;6768 if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;69 af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));70 &#125;71&#125;7273static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;74 Method originalMethod &#x3D; class_getInstanceMethod(theClass, originalSelector);75 Method swizzledMethod &#x3D; class_getInstanceMethod(theClass, swizzledSelector);76 method_exchangeImplementations(originalMethod, swizzledMethod);77&#125; 为什么要进行IMP交换？ 来看一下af_resume和af_suspend实现： 1- (void)af_resume &#123;2 NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);3 NSURLSessionTaskState state &#x3D; [self state];4 [self af_resume];5 6 &#x2F;&#x2F;&#x2F;因为经过method sswizzling后，此处的af_resume其实就是之前的resume，所以此处调用af_resume就是调用系统的resume。但是在程序中我们还是得使用resumee，其实际调用的是af_resume7 &#x2F;&#x2F;&#x2F;如果之前是其他状态，就变回resume状态，此处会通知调用taskDidResume8 if (state !&#x3D; NSURLSessionTaskStateRunning) &#123;9 [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];10 &#125;11&#125;1213&#x2F;&#x2F;&#x2F;同上14- (void)af_suspend &#123;15 NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);16 NSURLSessionTaskState state &#x3D; [self state];17 [self af_suspend];18 19 if (state !&#x3D; NSURLSessionTaskStateSuspended) &#123;20 [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];21 &#125;22&#125; 找到添加通知监听的地方，在AFURLSessionManager中： 1&#x2F;&#x2F;&#x2F;通知回调方法，添加相关通知2- (void)taskDidResume:(NSNotification *)notification &#123;3 &#x2F;&#x2F;&#x2F;发送通知的时候会将task添加进通知中4 NSURLSessionTask *task &#x3D; notification.object;5 &#x2F;&#x2F;&#x2F;判断这个任务是否是当前manager管理的，如果是就发送相关通知6 &#x2F;&#x2F;&#x2F;task的tasskDescription属性7 if ([task respondsToSelector:@selector(taskDescription)]) &#123;8 if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) &#123;9 dispatch_async(dispatch_get_main_queue(), ^&#123;10 [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task];11 &#125;);12 &#125;13 &#125;14&#125; 找到监听AFNetworkingTaskDidResumeNotification通知的类，用来处理“菊花”的加载和停止，看一下UIActivityIndicatorView的一个分类，此处涉及一个知识点，分类添加属性，直接来看代码： 1&#x2F;&#x2F;&#x2F;UIActivityIndicatorView+AFNetworking23@implementation UIActivityIndicatorView (AFNetworking)45&#x2F;&#x2F;&#x2F;通过runtime关联来添加一个AFActivityIndicatorViewNotificationObserver属性6- (AFActivityIndicatorViewNotificationObserver *)af_notificationObserver &#123;7 AFActivityIndicatorViewNotificationObserver *notificationObserver &#x3D; objc_getAssociatedObject(self, @selector(af_notificationObserver));8 if (notificationObserver &#x3D;&#x3D; nil) &#123;9 notificationObserver &#x3D; [[AFActivityIndicatorViewNotificationObserver alloc] initWithActivityIndicatorView:self];10 objc_setAssociatedObject(self, @selector(af_notificationObserver), notificationObserver, OBJC_ASSOCIATION_RETAIN_NONATOMIC);11 &#125;12 return notificationObserver;13&#125;1415- (void)setAnimatingWithStateOfTask:(NSURLSessionTask *)task &#123;16 [[self af_notificationObserver] setAnimatingWithStateOfTask:task];17&#125;1819&#x2F;&#x2F;&#x2F;添加通知监听20- (void)setAnimatingWithStateOfTask:(NSURLSessionTask *)task &#123;21 NSNotificationCenter *notificationCenter &#x3D; [NSNotificationCenter defaultCenter];2223 [notificationCenter removeObserver:self name:AFNetworkingTaskDidResumeNotification object:nil];24 [notificationCenter removeObserver:self name:AFNetworkingTaskDidSuspendNotification object:nil];25 [notificationCenter removeObserver:self name:AFNetworkingTaskDidCompleteNotification object:nil];26 27 if (task) &#123;28 if (task.state !&#x3D; NSURLSessionTaskStateCompleted) &#123;29 UIActivityIndicatorView *activityIndicatorView &#x3D; self.activityIndicatorView;30 if (task.state &#x3D;&#x3D; NSURLSessionTaskStateRunning) &#123;31 [activityIndicatorView startAnimating];32 &#125; else &#123;33 [activityIndicatorView stopAnimating];34 &#125;3536 [notificationCenter addObserver:self selector:@selector(af_startAnimating) name:AFNetworkingTaskDidResumeNotification object:task];37 [notificationCenter addObserver:self selector:@selector(af_stopAnimating) name:AFNetworkingTaskDidCompleteNotification object:task];38 [notificationCenter addObserver:self selector:@selector(af_stopAnimating) name:AFNetworkingTaskDidSuspendNotification object:task];39 &#125;40 &#125;41&#125;","categories":[{"name":"AFN","slug":"AFN","permalink":"http://yoursite.com/categories/AFN/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"将Flutter Module打包成pod私有库一键集成","slug":"将Flutter-Module打包成pod私有库一键集成","date":"2020-12-28T10:04:24.000Z","updated":"2020-12-28T10:32:08.827Z","comments":true,"path":"2020/2020-12-28-18:04:24/","link":"","permalink":"http://yoursite.com/2020/2020-12-28-18:04:24/","excerpt":"前言","text":"前言 用 Flutter 来开发，分两种，一种是一个纯Flutter项目开发，但是目前除了新开的一个纯 Flutter 项目，很大一部分都是 老项目接入 Flutter 来混编。 在 Flutter 官网 - Adding to an iOS app 这里，官方也给出了一些将 Flutter 集成进入现有 iOS 项目的方法。但是，这些都多多少少的不符合我们的需求。 介绍下Flutter Module想要把Flutter集成进现有的iOS项目，我们就必须使用Flutter Module。那就先用命令创建一个Flutter Module 1flutter create --template module flutter-test-module Flutter App 和 Flutter Module 的不同之处在于 pubspec.yaml 最后一段： 1# This section identifies your Flutter project as 123456789 module meant for2 # embedding in 123456789 native host app. These identifiers should _not_ ordinarily3 # be changed after generation - they are used to ensure that the tooling can4 # maintain consistency when adding or modifying assets and plugins.5 # They also do not have any bearing on your native host application&#39;s6 # identifiers, which may be completely independent or the same as these.7 module:8 androidX: true9 androidPackage: com.example.flutter_test_module10 iosBundleIdentifier: com.example.flutterTestModule 这里面设置了是否使用 androidx，Android 和 iOS 的 APP id。 iOS原生项目所需要的文件先说一下，iOS 原生项目引入 Flutter Module 需要如下 Framework： Flutter.framework App.framework FlutterPluginRegistrant.framework （如果有用到原生的插件 - 非纯 dart 编写） Pods_Runner.framework（如果有用到原生的插件 - 非纯 dart 编写） *.framework（插件的 framework） Flutter创建完成后，先来给iOS打个包 1flutter build ios --release--no-codesign 然后看一下打包出来的东西，路径为 build-&gt;ios-&gt;Release-iphoneos 如果有第三方库的话，这里面应该有上面说的3、4、5的framework，但是我们刚创建项目，什么都没有加，所以是没有任何framework的。然后去 .ios/Flutter 里找 1、2： 但是正式开发的时候我们不可能什么插件都不用，所以加上一个shared_preferences，再来打包看一下build文件夹： 可以看到确实出现了我们上面说的 3、4、5 framework，这样我们所需的 framework 全部集齐。 使用Cocoapods + Git 管理这里有一点，就是 Flutter.framework 超级大，有四五百兆，我们把它单独放在了一个 pod 里，而剩下的一些每次新增插件或变更代码都会跟着变动，所以他们是一个单独的 pod。也就是说，该 Flutter Module 一共有三个 git 仓库： Flutter Module 项目的仓库（编写代码等） Flutter Module 打包出来的 frameworks（不包含 Flutter.framework） Flutter.framework 仓库 这样的好处就是在我们编写完代码，运行 sh 文件的时候，不用去下载一个四五百兆的 flutter 引擎，脚本速度提升很快，并且其他的 iOS 项目也可以引用。 接下来使用命令pod lib create FlutterCoreModule 来创建一个名为FlutterCoreModule的私有库来管理 Flutter.framework。修改 KSFlutterCoreModule.podspec文件： 1s.vendored_frameworks &#x3D; [&#39;FlutterCoreModule&#x2F;Frameworks&#x2F;*.framework&#39;]2s.source_files &#x3D; &#39;FlutterCoreModule&#x2F;Frameworks&#x2F;*.framework&#x2F;Headers&#x2F;*.h&#39; 再使用命令pod lib create FlutterModule 来创建一个名为FlutterModule的私有库来管理Flutter Module 打包出来的 frameworks（不包含 Flutter.framework）。修改 FlutterModule.podspec文件： 1s.vendored_frameworks &#x3D; [&#39;KSFlutterModule&#x2F;Frameworks&#x2F;*.framework&#39;]2s.source_files &#x3D; &#39;KSFlutterModule&#x2F;Frameworks&#x2F;*.framework&#x2F;Headers&#x2F;*.h&#39;3s.dependency &#39;KSFlutterCoreModule&#39; 在原生工程中使用到这里pod私有库的制作完成了， Flutter Module 就完全引入到了现有的 iOS 工程中，关于如何运行代码，可以去 官方文档 - Adding a Flutter screen to an iOS app 中查找。 看下集成的示例代码： 1@import UIKit;2@import Flutter;34@interface KSAppDelegate : FlutterAppDelegate &lt;UIApplicationDelegate&gt;56@property (strong, nonatomic) FlutterEngine *flutterEngine;78@end 1#import &quot;KSAppDelegate.h&quot;2#import &lt;FlutterPluginRegistrant&#x2F;GeneratedPluginRegistrant.h&gt;34@implementation KSAppDelegate56- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions7&#123;8 self.flutterEngine &#x3D; [[FlutterEngine alloc] initWithName:@&quot;my flutteer engine&quot;];9 [self.flutterEngine run];10 [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine];11 12 return YES;13&#125; 1@import Flutter;2#import &quot;KSViewController.h&quot;3#import &quot;KSAppDelegate.h&quot;45@interface KSViewController ()6@end78@implementation KSViewController910- (void)viewDidLoad11&#123;12 [super viewDidLoad];13 &#x2F;&#x2F; Do any additional setup after loading the view, typically from 123456789 nib.14&#125;1516- (IBAction)showFlutterAction:(id)sender &#123;17 FlutterEngine *flutterEngine &#x3D; ((KSAppDelegate *)UIApplication.sharedApplication.delegate).flutterEngine;18 FlutterViewController *flutterVC &#x3D; [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil];19 [self presentViewController:flutterVC animated:YES completion:NULL];20&#125; 再来看看效果图： 喜大普奔，这就完成啦Flutter页面嵌入到原生项目的过程啦。 总结这样的集成方案感觉是比较方便的，Flutter端写完业务代码后build出来包后对应更新FlutterModule，iOS端直接pod update超级简单和方便。如有缺陷，希望大家提出，共同改进！🤝","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"}]},{"title":"Instruments分析和使用","slug":"Instruments分析和使用","date":"2020-11-26T09:25:35.000Z","updated":"2021-01-15T03:59:21.004Z","comments":true,"path":"2020/2020-11-26-17:25:35/","link":"","permalink":"http://yoursite.com/2020/2020-11-26-17:25:35/","excerpt":"一、苹果官方Instruments文档","text":"一、苹果官方Instruments文档 寻找官方文档小技巧（玩个花活） Apple Developer官网只有Xcode的入口, 修改 https://help.apple.com/Xcode 后面改成 instruments https://help.apple.com/instruments 也可以这样玩（善用搜索，你会发现很多惊喜） https://developer.apple.com/search/?q=instruments WWDC2019 Instruments 视频（可选中文字幕，点击访问） 使用前需要做的事情打开Malloc Stack. 可以让我们看到堆栈信息. (快捷键 Command + Shift + ,) Live Allocations Only : 只显示没有被释放(free)的内存堆栈. All Alloction and Free History : 显示所有的内存堆栈, 包括被释放(free)的. 导入或打开dSYM文件. 可以还原堆栈信息. 设置方式 -&gt; Build Settings 打开Instruments的方式 右键Dock栏的Xcode图标 (或者按住Control点击Xcode图标) -&gt; Open Developer Tool -&gt; Instruments Xcode菜单栏 -&gt; Open Developer Tool -&gt; Instruments Xcode APP -&gt; Show the Debug navigator -&gt; Profile in Instruments Instruments界面介绍https://help.apple.com/instruments/mac/current/#/dev2843b037 Instruments功能使用. 内存创建监控 Allocations.https://help.apple.com/instruments/mac/current/#/dev7b8f6eb6 Core Animation (新版Xcode模拟器测试). 新版本改到模拟器中, 看下面的 Core Animation 检测. 耗时分析 Time Profiler. 使用方法相同, 没有官方文档. 内存泄露 Leaks.https://help.apple.com/instruments/mac/current/#/dev022f987b 内存Debug的另一种方式. Debug Memory Graph (循环引用推荐使用此方式). 在图中, 黑色的线就是强引用, 灰色的线就是弱引用. 以此可以很明显的看出, 如果要释放的对象, 没 有被释放, 是被谁强引用了. 找到对应的代码. 预览 Core Animation 检测 模拟器 (simulator) 菜单栏 Debug -&gt; Color Blended Layers : 检测透明图层 Color Copied Images : 非32bit 颜色图片检测 Session 419 WWDC 2014中详细介绍了Color Copied Images Color Misaligned Images 打开开关后，看到部分视图会有黄色或洋红色（Magenta）的图层标记，代表其像素不对齐。 不对齐：视图或图片的点数(point)，不能换算成整数的像素值（pixel），导致显示视图的时候需要对没对齐的边缘进行额外混合计算，影响性能。 洋红色：UIView的frame像素不对齐，即不能换算成整数像素值。 黄色：UIImageView的图片像素大小与其frame.size不对齐，图片发生了缩放造成。 Color Off-screen Rendered 离屏渲染检测","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Xcode快捷指令","slug":"Xcode快捷指令","date":"2020-11-26T07:55:35.000Z","updated":"2020-11-26T10:38:17.145Z","comments":true,"path":"2020/2020-11-26-15:55:35/","link":"","permalink":"http://yoursite.com/2020/2020-11-26-15:55:35/","excerpt":"Xcode的快捷指令","text":"Xcode的快捷指令 _ 快捷键 说明 Command + shift + , Edit Scheme 编辑Scheme Command + shift + Y 打开/收起控制台 Command + shift + J 在工程文件目录定位到当前文件 Command + shift + 2 Devices and Simulators Command + shift + O 输入后点击可快速跳转到文件，还可输入方法名 Command + shift + F 搜索🔍 Command + shift + K Clean项目 Command + shift + L 打开资源文件 Command + shift + w 关闭项目 Command + shift + T 新开当前项目 Command + Option + ← → 收起展开方法代码块 Command + Shift + Option + ← → 收起展开全局代码块 Command + Option + 【 】 上移下移代码 Command + Option + W 保留当前打开，关闭其他文件 Command + , 偏好设置 Command + R Run Command + B Build Command + N 快速创建文件 Command + 【 】 左右移动代码 Command + F 当前文件搜索 Command + \\ 打断点 Command + y 关闭断点调试 Command + . 停止当前操作 Command + L 跳转到对应行 Command + W 关闭当前文件 command + 1，2 … 9 实操看下效果吧 Command + 0 打开/关闭左边导航 Control + 1 查看方法的调用者和被调用者 Control + 6 显示当前文件的方法，然后可以继续输方法名回车跳转 Control + 0 切换 Target Control + 4 切换项目 _","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"iOS对象所占内存大小之内存对齐","slug":"iOS对象所占内存大小之内存对齐","date":"2020-11-18T12:59:08.136Z","updated":"2020-11-19T07:29:44.544Z","comments":true,"path":"2020/2020-11-18-20:59:08/","link":"","permalink":"http://yoursite.com/2020/2020-11-18-20:59:08/","excerpt":"一、获取NSObject对象占用的空间大小","text":"一、获取NSObject对象占用的空间大小 创建一个 NSObject 对象, 分别调用 class_getInstanceSize 和 malloc_size方法 1NSObject *obj &#x3D; [[NSObject alloc] init];23&#x2F;&#x2F; 需要导入 #import &lt;objc&#x2F;runtime.h&gt;4NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));5 6&#x2F;&#x2F; 需要导入 #import &lt;malloc&#x2F;malloc.h&gt;7NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)(obj))); 查看Log 12019-11-05 15:10:22.210505+0800 Interview001-OC对象的本质[9215:816956] 822019-11-05 15:10:22.210675+0800 Interview001-OC对象的本质[9215:816956] 16 可以看出系统开辟了16个字节, 但是该对象只是用了8个字节，这是为什么呢? 点进 NSObject 可以看到下面的代码, NSObject 对象真正的是一个结构体指针, 所以会占用8个字节。 1&#x2F;&#x2F;&#x2F; An opaque type that represents an Objective-C class.2typedef struct objc_class *Class;3 4@interface NSObject &lt;NSObject&gt; &#123;5 Class isa ;6&#125; 在 OpenSource 找到 runtime 源码, 搜索 class_getInstanceSize 可以找到下面的代码, 可以看出 class_getInstanceSize 获取的是类的成员变量的 size, 并不是一个对象所占用的空间。 1size_t class_getInstanceSize(Class cls)2&#123;3 if (!cls) return 0;4 return cls-&gt;alignedInstanceSize();5&#125;67&#x2F;&#x2F; Class&#39;s ivar size rounded up to 123456789 pointer-size boundary.8uint32_t alignedInstanceSize() &#123;9 return word_align(unalignedInstanceSize());10&#125;1112size_t instanceSize(size_t extraBytes) &#123;13 size_t size &#x3D; alignedInstanceSize() + extraBytes;14 &#x2F;&#x2F; CF requires all objects be at least 16 bytes.15 if (size &lt; 16) size &#x3D; 16;16 return size;17&#125; 那为什么会分配16个字节了? 也是在 runtime 里找到了答案, 当 size &lt; 16 时, 会默认分配16个字节。可以参照 这篇文章 把.m文件编译成.cpp文件, 查看 NSObject真正的实现, 可以理解是对应 c++ 里的结构体。 二、自定义对象所占空间 自定义一个Person类 1@interface Person : NSObject2 &#123;3 &#125;4 @end5 6 @implementation Person7 @end 打印当前对象 1Person *p &#x3D; [[Person alloc] init];23NSLog(@&quot;%zd&quot;, class_getInstanceSize([Person class]));4NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)(p))); 得到的结果和 NSObject 对象一样的 12019-11-05 15:30:11.991698+0800 Interview001-OC对象的本质[9360:864510] 822019-11-05 15:30:11.991704+0800 Interview001-OC对象的本质[9360:864510] 16 给自定义对象添加1个成员变量, 再次打印 1@interface Person : NSObject2&#123;3 int _age;4&#125;5@end 12019-11-05 15:31:56.767972+0800 Interview001-OC对象的本质[9385:868476] 1622019-11-05 15:31:56.767978+0800 Interview001-OC对象的本质[9385:868476] 16 再次添加成员变量, 再次打印 1@interface Person : NSObject2&#123;3 int _age;4 int _number;5&#125;6@end 12019-11-05 15:34:16.503491+0800 Interview001-OC对象的本质[9414:874058] 1622019-11-05 15:34:16.503497+0800 Interview001-OC对象的本质[9414:874058] 16 很奇怪, 没有变化啊? 我们编程成.cpp再来分析 1struct Person_IMPL &#123;2 struct NSObject_IMPL NSObject_IVARS;3 int _age;4 int _number;5&#125;; 这时自定义对象包含了 1个结构体指针 (8字节) 1个 int _age (4字节) 1个 int _number (4字节)8 + 4 + 4 = 16 字节 没有添加任何成员变量时, 只有1个结构体指针, 所以会是8字节 添加1个成员变量时, 有1个结构体指针, 和1个 int 类型的值, 那就是 8 + 4 = 12, 为什么 class_getInstanceSize 得到的结果是16了. 其实扩容基数是8(内存对齐原因, 结构体的大小必须是最大成员大小的倍数), 8个字节不够了, 就开辟了8*2个字节, 依此类推 添加了2个成员变量时, 有1个结构体指针, 和2个 int 类型的值,那就是 8 + 4 + 4 = 16 再添加一个成员变量 1@interface Person : NSObject2&#123;3 int _age;4 int _number;5 int _sex;6&#125;7@end 12019-11-05 15:48:24.959113+0800 Interview001-OC对象的本质[9511:896453] 2422019-11-05 15:48:24.959120+0800 Interview001-OC对象的本质[9511:896453] 32 可以看出 class_getInstanceSize 已经是8*3=24字节了但是 malloc_size 却是 32了, 因为是以16为基数来扩容的, 因为 iOS 在分配对象内存时, 都是以16倍数来分配的 探索下系统是如何内存对齐的 运算符的含义 运算符 含义 描述 &gt;&gt; 右移 将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0 &lt;&lt; 左移 用来将一个数的各二进制位全部左移N位，高位舍弃，低位补0 &amp; 按位与 如果两个相应的二进制位都为1，则该位的结果值为1，否则为0 I 按位或 两个相应的二进制位中只要有一个为1，该位的结果值为1，否则为0 ~ 取反 对这个存储单元当前的值取反，也就是原来数中为1的变为0，0变为1 看一下源码 1static inline uint32_t word_align(uint32_t x) &#123;2 return (x + WORD_MASK) &amp; ~WORD_MASK;3&#125;4 5static inline size_t word_align(size_t x) &#123;6 return (x + WORD_MASK) &amp; ~WORD_MASK;7&#125;8 9static inline size_t align16(size_t x) &#123;10 return (x + size_t(15)) &amp; ~size_t(15);11&#125; 那么我们就不难理解了，分析一下： 1 &#x2F;**2return (x + WORD_MASK) &amp; ~WORD_MASK;34假设x为6560000 0111 771111 1000 ~WORD_MASK80000 1101 6 + 7 &#x3D; 1390000 1000 (x + WORD_MASK) &amp; ~WORD_MASK 结果：810*&#x2F; 我们自己来写个方法，换一个方式来达到系统内存对齐效果： 12class_getInstanceSize扩容基数是8：3 int funcMethod(int num) &#123;4 return (num + 7) &gt;&gt; 3 &lt;&lt; 3;5 &#x2F;&#x2F; &gt;&gt; 右移 将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0。6 &#x2F;&#x2F; &lt;&lt; 左移 用来将一个数的各二进制位全部左移N位，高位舍弃，低位补0。7 8 &#x2F;&#x2F; 0000 1101 6 + 7 &#x3D; 139 &#x2F;&#x2F; 0000 0001 &gt;&gt; 310 &#x2F;&#x2F; 0001 1000 &lt;&lt; 3 811 12 &#x2F;&#x2F; 0001 0011 12 + 7 &#x3D; 1913 &#x2F;&#x2F; 0000 0010 &gt;&gt; 314 &#x2F;&#x2F; 0001 0000 &lt;&lt; 3 1615 &#125;16 17 int main(int argc, char * argv[]) &#123;18 @autoreleasepool &#123;19 NSLog(@&quot;%d&quot;,funcMethod(6));20 NSLog(@&quot;%d&quot;,funcMethod(12));21 22 return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));23 &#125;24 &#125; 查看下log打印： 12020-11-19 14:29:16.424755+0800 Demo1[6321:2027201] 822020-11-19 14:29:16.425308+0800 Demo1[6321:2027201] 16 那么funcMethod具体做了什么？ 1 return (num + 7) &gt;&gt; 3 &lt;&lt; 3;2&#x2F;&#x2F; &gt;&gt; 右移 将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0。3&#x2F;&#x2F; &lt;&lt; 左移 用来将一个数的各二进制位全部左移N位，高位舍弃，低位补0。45&#x2F;&#x2F; 0000 1101 6 + 7 &#x3D; 136&#x2F;&#x2F; 0000 0001 &gt;&gt; 37&#x2F;&#x2F; 0001 1000 &lt;&lt; 3 结果：889&#x2F;&#x2F; 0001 0011 12 + 7 &#x3D; 1910&#x2F;&#x2F; 0000 0010 &gt;&gt; 311&#x2F;&#x2F; 0001 0000 &lt;&lt; 3 结果：16 malloc_size扩容基数是16： 1 int funcMethod(int num) &#123;2 return (num + 15) &gt;&gt; 4 &lt;&lt; 4;3&#125;45int main(int argc, char * argv[]) &#123;6 @autoreleasepool &#123;7 NSLog(@&quot;%d&quot;,funcMethod(8));8 NSLog(@&quot;%d&quot;,funcMethod(20));910 return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));11 &#125;12&#125; 查看下log打印： 12020-11-19 14:47:36.265334+0800 Demo1[6565:2044463] 1622020-11-19 14:47:36.265933+0800 Demo1[6565:2044463] 32 三、 结论 1个 NSObject 对象占用了16个字节 1个自定义对象占用了几个字节, 需要有多少成员变量, 同时还要计算上 NSObject 的 isa 指针大小, 同时为了对齐, 必须是16的倍数 四、 注意1- 如果自定义类有继承关系, 如 Student 继承于 Person, 要继续父类的成员变量2- 注意内存对齐问题, iOS 分配内存问题","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS基础Bundle、folder、group详解","slug":"iOS基础Bundle、folder、group详解","date":"2020-11-06T09:39:09.000Z","updated":"2020-11-18T13:00:26.242Z","comments":true,"path":"2020/2020-11-06-17:39:09/","link":"","permalink":"http://yoursite.com/2020/2020-11-06-17:39:09/","excerpt":"一、Bundles是什么？","text":"一、Bundles是什么？ Bundle是一个含有可执行的代码及代码所需资源，以特定标准的层次结构组合起来的文件夹。这里的可执行是指编译过后可直接运行的代码程序。一个典型的例子就是iOS程序打包后的ipa，我们解压ipa后会得到一个payload文件夹，进入文件夹之后会发现一个和ipa名称相同的.app文件夹。这个.app文件夹就是一个Bundle。 我们再来看一下苹果官方文档的描述： About Bundles12Bundles are a convenient way to deliver software in macOS and iOS. Bundles provide a simplified interface for end users and at the same time provide support for development. This chapter provides an introduction to bundles and discusses the role they play in macOS and iOS. Bundles and Packages1Although bundles and packages are sometimes referred to interchangeably, they actually represent very distinct concepts:23* A package is any directory that the Finder presents to the user as if it were a single file.4* A bundle is a directory with a standardized hierarchical structure that holds executable code and the resources used by that code.56Packages provide one of the fundamental abstractions that makes macOS easy to use. If you look at an application or plug-in on your computer, what you are actually looking at is a directory. Inside the package directory are the code and resource files needed to make the application or plug-in run. When you interact with the package directory, however, the Finder treats it like a single file. This behavior prevents casual users from making changes that might adversely affect the contents of the package. For example, it prevents users from rearranging or deleting resources or code modules that might prevent an application from running correctly. 这里还描述了Bundle和Package的不同定义： Package是Finder呈现给用户的任何目录，就好像它是一个单独的文件一样。 Bundle是一个具有标准化层次结构的目录，其中包含可执行代码和该代码使用的资源。 系统如何识别Bundle呢？一般而言一个文件夹如果带着.app，.bundle，.framework，.plugin，.kext等特定后缀，那么系统就认为是Bundle。如果使用Xcode创建项目的话，Xcode会提供相应的模板来生成正确的Bundle类型。从上面的后缀我们也可以看出Bundle主要分为： Appliction。应用程序，包含代码和资源。iOS和macOS的app就是这种。 Frameworks。框架，包含动态共享库和相应资源。我们常用的系统库和第三方库都属于这种。 Plug-Ins。插件，macOS很多的系统功能支持插件，一种动态加载代码模块的方式。 使用Bundle可以很方便的管理程序的文件内容，进行本地化设置、程序移动和运行等等。 我们来看一下苹果官方文档的描述： 1How the System Identifies Bundles and Packages23The Finder considers a directory to be a package if any of the following conditions are true:45* The directory has a known filename extension: .app, .bundle, .framework, .plugin, .kext, and so on.6* The directory has an extension that some other application claims represents a package type; see Document Packages.7* The directory has its package bit set.89The preferred way to specify a package is to give the package directory a known filename extension. For the most part, Xcode takes care of this for you by providing templates that apply the correct extension. All you have to do is create an Xcode project of the appropriate type.1011Most bundles are also packages. For example, applications and plug-ins are typically presented as a single file by the Finder. However, this is not true for all bundle types. In particular, a framework is a type of bundle that is treated as a single unit for the purposes of linking and runtime usage, but framework directories are transparent so that developers can view the header files and other resources they contain. Bundles的内部结构iOS Application Bundle的结构Application类型的bundle是很常见的，一般里面会包含一下几中类型的文件： Info.plist文件。每个程序中必须有这个文件，因为它包含了程序运行的配置信息，是系统运行程序的依据。 可执行代码文件。这是程序的主体，包含了程序的进入点和链接的静态代码。 资源文件。程序运行过程中需要的资源，比如图片，音频，视频，多语言的字符串文件，nib文件，数据文件，配置文件等等。这里面的大部分文件都可以根据语言、地区、设备通过特定的结构或命名方式加以区分，程序会自动识别加载。 其他支持文件。Mac app可以嵌入高层资源，比如私有库，插件，文件末班，自定义数据资源等等。iOS app可以包含自定义数据资源，但是不能包含私有库和插件。 如果我们对于ipa中的.app文件夹右键显示包内容，我们可以看到app bundle的整体结构如下： 1MyApp 2 MyApp &#x2F;&#x2F;代码编译链接后的可执行文件 3 Info.plist &#x2F;&#x2F;程序信息4 Assets.car &#x2F;&#x2F;Assets中的资源对应的文件。 5 MyAppIcon.png &#x2F;&#x2F;所有的icon图片 6 LaunchImage.png &#x2F;&#x2F;所有启动图片 7 nibs &#x2F;&#x2F;工程中的xib，storyboard生成的nib文件 8 customResource &#x2F;&#x2F;工程目录下或者更里层文件夹下的图片，音、视频，数据文件等自定义资源 9 customBundle.bundle &#x2F;&#x2F;工程中使用的其他第三方或资源的bundle 10 en.lproj &#x2F;&#x2F;语言区分的文件夹，可以使字符串、图片，nib文件等11 MyString 12 MyImage13 zh-Hans.lproj 14 MyString 15 MyImage 16 PkgInfo &#x2F;&#x2F;系统识别信息 17 _CodeSignature &#x2F;&#x2F;签名信息文件夹，里面的CodeResources包含对bundle中的所有资源文件的签名信息 18 embedded.mobileprovision &#x2F;&#x2F;打包的配置文件信息 Assets.car无法直接打开，可以使用工具 cartool 列出包含的所有文件名称。PkgInfo、签名信息和嵌入配置文件都是打包后生成的，是系统验证app的依据。 Framework Bundle结构Framework Bundle和app bundle的最大不同在于框架库有版本控制，因此必须包含版本列表和当前版本信息。Framework的bundle结构如下： 1MyFramework.framework&#x2F;2 MyFramework -&gt; Versions&#x2F;Current&#x2F;MyFramework 3 Resources -&gt; Versions&#x2F;Current&#x2F;Resources 4 Versions&#x2F;5 A&#x2F;6 MyFramework7 Headers&#x2F;8 MyHeader.h9 Resources&#x2F; 10 Eglish.lproj&#x2F;11 InfoPlist.strings 12 Info.plist13 Current -&gt; A 上面的根目录下的MyFramework和Resources，以及Versions下面的current 都是文件引用，表明引用文件的位置。真正的代码，资源，header等内容都放在Versions文件夹下面的具体版本文件夹中，Current就指向当前版本的引用。 关于多语言本地化文件，是按照language_region.lproj的格式命名的，比如en_GB表明英语英国，zh_Hans表示中文中国大陆。 Bundles的基本使用使用bundle主要都是围绕着定位资源路径而来的。包括：获取bundle及其信息（不管是main bundle还是其他bundle），获取资源路径（根据资源名称和类型定位），使用系统API直接获取资源（比如图片、音频、本地化字符串、context help，nibs，Info.plist内容等等），具体使用可以参考 Class Bundle文档 在磁盘上查找资源时，Bundle对象遵循特定的搜索模式。首先返回全局资源（即不在特定于语言的.lproj目录中的资源），然后返回特定于区域和语言的资源。此搜索模式表示捆绑包按以下顺序查找资源： 全局（非本地化）资源 特定区域的本地化资源（基于用户的区域首选项） 特定语言的本地化资源（基于用户的语言首选项） 开发语言资源（由bundle的Info.plist文件中的CFBundleDevelopmentRegion键指定） 由于全局资源优先于特定语言的资源，因此您不应在应用程序中同时包含给定资源的全局和本地化版本。存在资源的全局版本时，永远不会返回特定语言的版本。这种优先权的原因是性能。如果首先搜索本地化资源，则bundle对象可能会浪费时间在返回全局资源之前搜索不存在的本地化资源。 在查找资源文件时，bundle对象在确定要返回的文件时会自动考虑许多标准文件名修饰符。可以为特定设备（iphone，ipad）或特定屏幕分辨率（@2x，@ 3x）标记资源。指定所需资源的名称时，请不要包含这些修饰符。 bundle对象选择最适合底层设备的文件。 参考资料：Bundle Programming GuideClass Bundle Reference 二、iOS Xcode工程目录中folder和group的区别说到folder和group大家应该并不陌生，XCode工程目录里面，你会发现两个不同颜色的文件夹，一种是蓝色的，一种是黄色的，最常见的是黄色的。这里我们要探讨的就是黄色和蓝色文件夹的区别： group （黄色文件夹）一般只在你的工程中是文件夹的形式，但是在本地的目录中还是以散乱的形式放在一起的，除非你是从外部以group的形式引用进来的。（ps：目前版本已经将新建立的分组创建成真正的文件夹） folder （蓝色文件）只能作为资源，整个引用进项目，不参与编译，也就是说，以folder形式引用进来的文件，不能被放在complie sources列表里面。 我拖动外部的文件夹 “切图”到我的xcode工程目录下面，会弹出对话框，如图： copy，是指文件不在项目的目录下面，例如项目在桌面上，文件在 Download 下，你 copy 就会被复制到项目里面。如果文件原本就在项目里面，则不执行任何操作。这里不管它，重点是下面的单选框。 这里我选择的是以folder的形式引用文件夹，点击完成，如下图所示，文件夹是蓝色的，并且编译文件列表里面没有”切图” 这个文件，证明文件夹引用，只会引用文件夹，文件夹里面的东西都会直接拷贝到bundle包，不参与编译。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS 组件库制作流程","slug":"组件库制作流程","date":"2020-10-24T08:52:17.000Z","updated":"2020-10-24T08:52:17.000Z","comments":true,"path":"2020/2020-08-25-17:25:13/","link":"","permalink":"http://yoursite.com/2020/2020-08-25-17:25:13/","excerpt":"一、制作流程","text":"一、制作流程 11、新建XX.git仓库2 2、新建文件夹 XX并cd到文件夹3 3、pod lib create XX4 （1）是否需要一个例子工程： YES5 （2）选择一个测试框架：Specta6 （3）是否基于View测试：YES7 （4）类的前缀：XB 8 4、找到ReplaceMe所在的文件夹，并将源码放入此文件夹9 5、cd Example 并执行 pod update --verbose --no-repo-update10 6、编写demo，并测试通过11 7、提交到xx.git仓库，并update tag12 8、编辑podspec文件 【example：见5】并验证是否可用13 pod lib lint14 9、添加XX.podspec 到中心仓库15 pod repo push http:&#x2F;&#x2F;gitlab.devops.xxx.com&#x2F;ios&#x2F;PrivateCocoaPods.git XX.podspec16 pod repo push http:&#x2F;&#x2F;gitlab.devops.xxx.com&#x2F;ios&#x2F;PrivateCocoaPods.git XX.podspec --verbose --use-libraries --allow-warnings17 10、检查是否添加成功18 pod search XX19 11、导入到项目中：20 pod &#39;XX&#39; 二、更新库11、编写更新代码2 2、提交到git仓库，并update tag3 3、更新XX.podspec文件版本号及更新版本记录4 4、更新XX.podspec 到中心仓库5 pod repo push http:&#x2F;&#x2F;gitlab.devops.xxx.com&#x2F;ios&#x2F;PrivateCocoaPods.git XX.podspec6 pod repo push http:&#x2F;&#x2F;gitlab.devops.xxx.com&#x2F;ios&#x2F;PrivateCocoaPods.git XX.podspec --verbose --use-libraries --allow-warnings 三、使用中遇到的问题看下面使用Cocoapods创建私有podspecCocoapods代码管理pod update慢私有pod相互依赖 1以上步骤都OK，搜索不到2rm ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json34私有pod specs相互依赖5$pod spec lint QZCrashLogManager.podspec –allow-warnings –sources&#x3D;xsl-mobile-cocoaspecs,master 四、podspec格式与必填1Pod::Spec.new do |s|2 s.name &#x3D; &quot;PodTestLibrary&quot; #名称3 s.version &#x3D; &quot;0.1.0&quot; #版本号4 s.summary &#x3D; &quot;Just Testing.&quot; #简短介绍，下面是详细介绍5 s.description &#x3D; &lt;&lt;-DESC6 这里是详细介绍7 DESC8 s.homepage &#x3D; &quot;http:&#x2F;&#x2F;gitlab.devops.xxx.com&#x2F;ios&#x2F;XX.git&quot; #主页,这里要填写可以访问到的地址，不然验证不通过9 # s.screenshots &#x3D; &quot;www.example.com&#x2F;screenshots_1&quot;, &quot;www.example.com&#x2F;screenshots_2&quot; #截图10 s.license &#x3D; &#39;MIT&#39; #开源协议11 s.author &#x3D; &#123; &quot;xuebiao&quot; &#x3D;&gt; &quot;xuebiao@ksjgs.com&quot; &#125; #作者信息12 s.source &#x3D; &#123; :git &#x3D;&gt; &quot;http:&#x2F;&#x2F;gitlab.devops.xxx.com&#x2F;ios&#x2F;XX.git&quot;, :tag &#x3D;&gt; s.version.to_s &#125; #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS13 # s.social_media_url &#x3D; &#39;https:&#x2F;&#x2F;twitter.com&#x2F;&lt;TWITTER_USERNAME&gt;&#39; #多媒体介绍地址1415 s.platform &#x3D; :ios, &#39;8.0&#39; #支持的平台及版本16 s.requires_arc &#x3D; true #是否使用ARC，如果指定具体文件，则具体的问题使用ARC1718 s.source_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*&#39; #代码源文件地址，**&#x2F;*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置19 s.resource_bundles &#x3D; &#123;20 &#39;PodTestLibrary&#39; &#x3D;&gt; [&#39;Pod&#x2F;Assets&#x2F;*.png&#39;]21 &#125; #资源文件地址2223 s.public_header_files &#x3D; &#39;Pod&#x2F;Classes&#x2F;**&#x2F;*.h&#39; #公开头文件地址24 s.frameworks &#x3D; &#39;UIKit&#39; #所需的framework，多个用逗号隔开25 s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 2.3&#39; #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency26end podspec进阶1 # 微信分享2 s.subspec &#39;UMSocialWechat&#39; do |ss|3 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;UMSocialWechat&#x2F;*.&#123;h,m&#125;&#39;4 ss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;UMSocialWechat&#x2F;*.h&#39;5 ss.vendored_libraries &#x3D; &#39;KSThirdPartToolModule&#x2F;UMSocialWechat&#x2F;*.a&#39;6 ss.dependency &#39;UMCCommon&#39;7#ss.dependency &#39;UMCSecurityPlugins&#39;8#ss.dependency &#39;UMCShare&#x2F;Social&#x2F;ReducedQQ&#39;9 ss.dependency &#39;UMCShare&#x2F;Social&#x2F;ReducedSina&#39;10 ss.dependency &#39;UMCShare&#x2F;Social&#x2F;QQ&#39;11 ss.dependency &#39;WechatOpenSDK&#39;12 end1314 # 讯飞语音识别15 s.subspec &#39;iflyMSC&#39; do |ss|16 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;iflyMSC&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;17 ss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;iflyMSC&#x2F;**&#x2F;*.h&#39;18 ss.vendored_frameworks &#x3D; [&#39;KSThirdPartToolModule&#x2F;iflyMSC&#x2F;iflyMSC.framework&#39;]19 ss.libraries &#x3D; &#39;c++&#39;,&#39;z&#39;20 ss.frameworks &#x3D; &#39;Contacts&#39;,&#39;AddressBook&#39;,&#39;AddressBookUI&#39;,&#39;AVFoundation&#39;,&#39;SystemConfiguration&#39;,&#39;Foundation&#39;,&#39;CoreTelephony&#39;,&#39;AudioToolbox&#39;,&#39;UIKit&#39;,&#39;CoreLocation&#39;,&#39;QuartzCore&#39;,&#39;CoreGraphics&#39;21 end2223 # 智齿24 s.subspec &#39;SobotLib&#39; do |ss|25 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;SobotLib&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;26 ss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;SobotLib&#x2F;**&#x2F;*.h&#39;27 ss.vendored_libraries &#x3D; [&#39;KSThirdPartToolModule&#x2F;SobotLib&#x2F;libSobotLib.a&#39;]28 end2930 # GVUserDefaults31 s.subspec &#39;KSGVUserDefaults&#39; do |ss|32 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSGVUserDefaults&#x2F;**&#x2F;*&#39;33 ss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSGVUserDefaults&#x2F;**&#x2F;*.h&#39;34 end3536 # SSKeychain37 s.subspec &#39;KSSSKeychain&#39; do |ss|38 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSSSKeychain&#x2F;*&#39;39 ss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSSSKeychain&#x2F;*.h&#39;40 ss.dependency &#39;KSThirdPartToolModule&#x2F;KSGVUserDefaults&#39;4142 ss.subspec &#39;KSSSKeychain_0&#39; do |sss|43 sss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSSSKeychain&#x2F;SAMKeychain_0&#x2F;**&#x2F;*&#39;44 sss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSSSKeychain&#x2F;**&#x2F;*.h&#39;45 end4647 ss.subspec &#39;KSSSKeychain_1&#39; do |sss|48 sss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSSSKeychain&#x2F;SAMKeychain_1&#x2F;**&#x2F;*&#39;49 sss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSSSKeychain&#x2F;**&#x2F;*.h&#39;50 end51 end5253 # 数字联盟54 s.subspec &#39;KSSZLM&#39; do |ss|55 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSSZLM&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;56 ss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSSZLM&#x2F;**&#x2F;*.h&#39;57 ss.vendored_frameworks &#x3D; [&#39;KSThirdPartToolModule&#x2F;KSSZLM&#x2F;du.framework&#39;]58 end5960 s.subspec &#39;JKDBModel&#39; do |ss| 61 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;JKDBModel&#x2F;**&#x2F;*&#39;62 ss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;JKDBModel&#x2F;**&#x2F;*.h&#39;63 ss.dependency &#39;KSBaseModule&#39;64 ss.dependency &#39;KSFMDB&#39;65 end6667 s.subspec &#39;KSOpenURLTool&#39; do |ss| 68 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSOpenURLTool&#x2F;**&#x2F;*&#39;69 ss.public_header_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSOpenURLTool&#x2F;**&#x2F;*.h&#39;70 ss.dependency &#39;KSCommonCategory&#39;71 ss.dependency &#39;KSCommonMacros&#39;72 end7374 s.subspec &#39;KSDateFormatterManager&#39; do |ss|75 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSDateFormatterManager&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;76 ss.dependency &#39;KSCommonCategory&#39;77 ss.dependency &#39;KSCommonMacros&#39;78 end79 80 s.subspec &#39;FCFileManager&#39; do |ss|81 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;FCFileManager&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;82 end8384 s.subspec &#39;KSCameraManager&#39; do |ss| 85 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSCameraManager&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;86 ss.dependency &#39;KSThirdPartToolModule&#x2F;KSAlertController_new&#39;87 ss.dependency &#39;KSCommonConstants&#39;88 end8990 s.subspec &#39;YCDownloadSession&#39; do |ss|91 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;YCDownloadSession&#x2F;**&#x2F;*&#39;92 end9394 s.subspec &#39;KSAlertController_new&#39; do |ss|95 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSAlertController_new&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;96 ss.dependency &#39;KSUICommonCategory&#39;97 end9899 s.subspec &#39;IPAddress&#39; do |ss|100 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;IPAddress&#x2F;**&#x2F;*&#39;101 end102103 s.subspec &#39;KSCodeGenerator&#39; do |ss|104 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSCodeGenerator&#x2F;**&#x2F;*&#39;105 ss.frameworks &#x3D; &#39;CoreImage&#39;,&#39;CoreGraphics&#39;,&#39;Foundation&#39;106 end107108 s.subspec &#39;KSAssociationOriginalObject&#39; do |ss|109 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSAssociationOriginalObject&#x2F;*&#39;110 end111112 s.subspec &#39;KSCustomPresentationController&#39; do |ss|113 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSCustomPresentationController&#x2F;*&#39;114 end115116 s.subspec &#39;KSCircleSlider&#39; do |ss|117 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSCircleSlider&#x2F;*&#39;118 ss.dependency &#39;KSUICommonCategory&#39;119 end120121 s.subspec &#39;KSGCDDelay&#39; do |ss|122 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSGCDDelay&#x2F;*&#39;123 end124125 s.subspec &#39;KSJailbreakDetectTool&#39; do |ss|126 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSJailbreakDetectTool&#x2F;*&#39;127 end128129 s.subspec &#39;KSTextField&#39; do |ss|130 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSTextField&#x2F;*&#39;131 end132133 s.subspec &#39;GCD&#39; do |ss|134 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;GCD&#x2F;*&#39;135 end136137 s.subspec &#39;KSAllTypeJumpToViewControllerTool&#39; do |ss|138 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSAllTypeJumpToViewControllerTool&#x2F;*&#39;139 ss.dependency &#39;KSBaseModule&#39;140 end141142 s.subspec &#39;KSMutableTypeTool&#39; do |ss|143 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSMutableTypeTool&#x2F;*&#39;144 end145146 s.subspec &#39;KSCountdownCircleView&#39; do |ss|147 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSCountdownCircleView&#x2F;*&#39;148 ss.dependency &#39;KSThirdPartToolModule&#x2F;KSWeakProxy&#39;149 end150151 s.subspec &#39;KSWeakProxy&#39; do |ss|152 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSWeakProxy&#x2F;*&#39;153 end154155 # KSImageTool156 s.subspec &#39;KSImageTool&#39; do |ss|157 ss.source_files &#x3D; &#39;KSThirdPartToolModule&#x2F;KSImageTool&#x2F;**&#x2F;*&#39;158 ss.dependency &#39;SDWebImage&#39;159 ss.dependency &#39;KSAPPServerConfigModule&#39;160 ss.dependency &#39;KSCommonMacros&#39;161 ss.dependency &#39;KSCommonCategory&#39;162 end163164 s.dependency &#39;KSCommonConstants&#39;165 s.dependency &#39;KSCommonMacros&#39;166 s.dependency &#39;KSCommonCategory&#39;167 s.dependency &#39;KSUICommonCategory&#39;168 s.dependency &#39;Baymax&#39;169 s.dependency &#39;KSLBLelinkKitModule&#39;,&#39;1.0.0.1&#39;","categories":[{"name":"架构知识","slug":"架构知识","permalink":"http://yoursite.com/categories/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"组件库制作","slug":"组件库制作","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%BA%93%E5%88%B6%E4%BD%9C/"}]},{"title":"Swift+RXSwift","slug":"Swift-RXSwift","date":"2020-10-24T08:46:32.000Z","updated":"2020-10-24T10:00:37.000Z","comments":true,"path":"2020/Sat Oct 24 2020 16:46:32 GMT+0800 (中国标准时间)/","link":"","permalink":"http://yoursite.com/2020/Sat%20Oct%2024%202020%2016:46:32%20GMT+0800%20(%E4%B8%AD%E5%9B%BD%E6%A0%87%E5%87%86%E6%97%B6%E9%97%B4)/","excerpt":"分享一下在日常使用RxSwift进行开发的MVVM模式","text":"分享一下在日常使用RxSwift进行开发的MVVM模式 一个有collectionView的列表页，MVVM文件目录结构： 接口 KSUserAvatarAPI1import Moya23enum KSUserAvatarAPI &#123;4 &#x2F;&#x2F;&#x2F;获取头像列表5 case list(page: Int)6 &#x2F;&#x2F;&#x2F;上传头像7 case updateAvatar(headImgUrl: String, headImgId: String)8 &#x2F;&#x2F;&#x2F;会员广告信息 投放位置: 1-故事播放页;2-IP互动页;3-头像页面;4-家长中心;5-会员频道9 case userVipAdver(position: Int)10&#125;1112extension KSUserAvatarAPI: TargetType &#123;13 14 var baseURL: URL &#123;15 return URL(string: KSAppConfigEnvirenmentManager.default.Domain()) ?? URL(target: self)16 &#125;1718 var path: String &#123;19 switch self &#123;20 case .list:21 return KSNetworkBusinessAPIConstants.User.headList22 case .updateAvatar:23 return KSNetworkBusinessAPIConstants.User.headUpdate24 case .userVipAdver:25 return KSNetworkBusinessAPIConstants.User.userVipAdver26 &#125;27 &#125;2829 var method: Moya.Method &#123;30 switch self &#123;31 case .list,.userVipAdver:32 return .get33 case .updateAvatar:34 return .post35 &#125;36 &#125;3738 var task: Task &#123;39 switch self &#123;40 case let .list(page):41 let dict &#x3D; [&quot;pageNo&quot;: page, &quot;pageSize&quot;: 100]42 return .requestParameters(parameters: dict, encoding: URLEncoding.default)43 case let .updateAvatar(headImgUrl, headImgId):44 let dict &#x3D; [&quot;headImgUrl&quot;: headImgUrl, &quot;headImgId&quot;: headImgId]45 return .requestParameters(parameters: dict, encoding: JSONEncoding.default)46 case let .userVipAdver(position):47 let dict &#x3D; [&quot;position&quot;: position]48 return .requestParameters(parameters: dict, encoding: URLEncoding.default)49 &#125;50 &#125;5152 var sampleData: Data &#123;53 let text &#x3D; &quot;&quot;&quot;54 &quot;&quot;&quot;55 return text.data(using: .utf8) ?? Data()56 &#125;5758 var headers: [String: String]? &#123;59 return [&quot;Content-Type&quot;: &quot;application&#x2F;json&quot;]60 &#125;6162 var parameterEncoding: ParameterEncoding &#123;63 &#x2F;&#x2F;&#x2F; 参数默认进行url编码64 return URLEncoding.default65 &#125;6667 var multipartBody: [Moya.MultipartFormData]? &#123;68 return nil69 &#125;70 71&#125; 数据模型 KSUserAvatarModel1import ObjectMapper2import ObjectMapperAdditions34class KSUserAvatarModel: KSBaseModel &#123;5 6 &#x2F;&#x2F;&#x2F; 总数量7 var totalCount &#x3D; 08 &#x2F;&#x2F;&#x2F; 页码9 var pageNum &#x3D; 010 &#x2F;&#x2F;&#x2F; 每页的数量11 var pageSize &#x3D; 012 &#x2F;&#x2F;&#x2F; 总页数13 var totalPage &#x3D; 01415 &#x2F;&#x2F;&#x2F; 列表16 var list: [Item] &#x3D; []17 18 override func mapping(map: Map) &#123;19 super.mapping(map: map)20 totalCount &lt;- (map[&quot;totalCount&quot;], IntTransform())21 list &lt;- map[&quot;list&quot;]22 pageNum &lt;- (map[&quot;pageNum&quot;], IntTransform())23 pageSize &lt;- (map[&quot;pageSize&quot;], IntTransform())24 totalPage &lt;- (map[&quot;totalPage&quot;], IntTransform())25 &#125;26 27 class Item: KSBaseModel &#123;28 29 &#x2F;&#x2F;&#x2F; 虚拟商品id30 var virtualId &#x3D; &quot;&quot;31 &#x2F;&#x2F;&#x2F; 图片地址32 var backGroundImg &#x3D; &quot;&quot;33 &#x2F;&#x2F;&#x2F; 头像类型free-免费member-会员34 var exchangeType &#x3D; &quot;&quot;35 &#x2F;&#x2F;&#x2F; 是否展示上新图标true显示false不显示36 var isShowNewIcon &#x3D; false37 &#x2F;&#x2F;&#x2F; 是否展示会员图标true显示false不显示38 var isShowMemberIcon &#x3D; false39 40 override func mapping(map: Map) &#123;41 super.mapping(map: map)42 virtualId &lt;- (map[&quot;virtualId&quot;], StringTransform())43 backGroundImg &lt;- (map[&quot;backGroundImg&quot;], StringTransform())44 exchangeType &lt;- (map[&quot;exchangeType&quot;], StringTransform())45 isShowNewIcon &lt;- (map[&quot;isShowNewIcon&quot;], BoolTransform())46 isShowMemberIcon &lt;- (map[&quot;isShowMemberIcon&quot;], BoolTransform())47 &#125;48 &#125;49&#125; KSUserAvatarListCell1import UIKit2import RxSwift3import RxCocoa45class KSUserAvatarListCell: KSBaseCollectionViewCell &#123;6 &#x2F;&#x2F;&#x2F; MARK: - Property7 private var disposeBag &#x3D; DisposeBag()8 9 &#x2F;&#x2F;&#x2F; MARK: - UI10 11 &#x2F;&#x2F;&#x2F; 头像背景图12 private lazy var avatarBgImageView: UIImageView &#x3D; &#123;13 var imageView &#x3D; UIImageView()14 imageView.configueTheme([ksImage: ks_mine_pic_avatar_bg_default])15 return imageView16 &#125;()17 18 &#x2F;&#x2F;&#x2F; 头像19 private lazy var avatarImageView: UIImageView &#x3D; &#123;20 var imageView &#x3D; UIImageView()21 imageView.cornerRadius &#x3D; 30.adaptor22 imageView.contentMode &#x3D; .scaleAspectFill23 return imageView24 &#125;()2526 &#x2F;&#x2F;&#x2F; 会员icon标识27 private lazy var vipIconImageView: UIImageView &#x3D; &#123;28 var imageView &#x3D; UIImageView()29 imageView.configueTheme([ksImage: ks_mine_icon_vip])30 return imageView31 &#125;()32 33 &#x2F;&#x2F;&#x2F; 上新icon标识34 private lazy var newIconImageView: UIImageView &#x3D; &#123;35 var imageView &#x3D; UIImageView()36 imageView.configueTheme([ksImage: ks_mine_tag_avatar_xin])37 return imageView38 &#125;()39 40 &#x2F;&#x2F;&#x2F; 选中icon标识41 private lazy var selectIconImageView: UIImageView &#x3D; &#123;42 var imageView &#x3D; UIImageView()43 imageView.configueTheme([ksImage: ks_common_icon_select_blue_selected])44 return imageView45 &#125;()4647 48 &#x2F;&#x2F; MARK: - Setter49 public var cellViewModel: KSUserAvatarListCellViewModel? &#123;50 didSet &#123;51 guard let cellViewModel &#x3D; cellViewModel, let model &#x3D; cellViewModel.outputs.model.value else &#123; return &#125;52 53 cellViewModel.outputs.isSelected.asDriver().map &#123; [weak self] (selected) in54 guard let self &#x3D; self else &#123;return !selected&#125;55 56 self.avatarBgImageView.configueTheme([ksImage: selected ? ks_mine_pic_avatar_bg_select : ks_mine_pic_avatar_bg_default])57 return !selected58 &#125;.drive(selectIconImageView.rx.isHidden).disposed(by: disposeBag)5960 vipIconImageView.isHidden &#x3D; !model.isShowMemberIcon61 newIconImageView.isHidden &#x3D; !model.isShowNewIcon62 avatarImageView.ks_setImage(urlString: model.backGroundImg, placeholderImage: nil)63 &#125;64 &#125;65&#125;6667&#x2F;&#x2F; MARK: - Override68extension KSUserAvatarListCell &#123;69 70 override func prepareForReuse() &#123;71 super.prepareForReuse()72 disposeBag &#x3D; DisposeBag()73 &#125;74 75 override func configDefaultInit() &#123;76 super.configDefaultInit()77 &#125;78 79 override func configSubviews() &#123;80 super.configSubviews()81 contentView.addSubviews(avatarBgImageView, avatarImageView,vipIconImageView, newIconImageView, selectIconImageView)82 &#125;83 84 override func configLayoutSubviews() &#123;85 super.configLayoutSubviews()86 87 avatarBgImageView.snp.makeConstraints &#123; (make) in88 make.top.equalTo(15.adaptor)89 make.left.equalToSuperview()90 make.width.equalTo(71.adaptor)91 make.height.equalTo(77.adaptor)92 &#125;93 94 avatarImageView.snp.makeConstraints &#123; (make) in95 make.top.equalTo(avatarBgImageView).offset(5.adaptor)96 make.width.height.equalTo(60.adaptor)97 make.centerX.equalTo(avatarBgImageView)98 &#125;99 100 vipIconImageView.snp.makeConstraints &#123; (make) in101 make.top.equalTo(avatarBgImageView).offset(2.adaptor)102 make.right.equalTo(avatarBgImageView.snp.right).offset(-2.adaptor)103 make.width.height.equalTo(20.adaptor)104 &#125;105 106 newIconImageView.snp.makeConstraints &#123; (make) in107 make.left.equalTo(avatarBgImageView.snp.left).offset(-3.5.adaptor)108 make.top.equalTo(avatarBgImageView).offset(3.adaptor)109 make.width.height.equalTo(20.adaptor)110 &#125;111 112 selectIconImageView.snp.makeConstraints &#123; (make) in113 make.right.equalTo(avatarBgImageView)114 make.bottom.equalTo(avatarBgImageView).offset(-7.adaptor)115 make.width.height.equalTo(20.adaptor)116 &#125;117 &#125;118&#125; 控制器 KSUserAvatarViewController1import UIKit2import RxSwift3import RxCocoa4import RxDataSources5import KSVipBusinessModule67class KSUserAvatarViewController: KSBaseCollectionViewController &#123;8 struct Style &#123;9 static let space: CGFloat &#x3D; 25.010 &#x2F;&#x2F;&#x2F; w 71 h 7711 static let cellWidth &#x3D; 71.012 static let cellHeight &#x3D; 100.013 &#125;1415 private let disposeBag &#x3D; DisposeBag()16 private let viewModel &#x3D; KSUserAvatarViewModel()17 18 private lazy var vipAdverManager: KSUserVipAdverManager &#x3D; &#123;19 let manager &#x3D; KSUserVipAdverManager()20 return manager21 &#125;()2223 &#x2F;&#x2F;&#x2F; MARK: - UI24 25 &#x2F;&#x2F;&#x2F; 背景图26 private lazy var backgroundImageView: UIImageView &#x3D; &#123;27 let imageView &#x3D; UIImageView()28 imageView.configueTheme([ksImage: ks_mine_pic_avatar_big_bg])29 imageView.contentMode &#x3D; .scaleAspectFill30 return imageView31 &#125;()32 33 &#x2F;&#x2F;&#x2F;头像视图34 private lazy var avatarView: KSAvatarView &#x3D; &#123;35 let avatarView &#x3D; KSAvatarView()36 return avatarView37 &#125;()3839 &#x2F;&#x2F;&#x2F;会员引导背景图40 private lazy var vipGuideButton: UIButton &#x3D; &#123;41 let button &#x3D; UIButton()42 button.configueTheme([ksBackgroundImageNormal: ks_common_pic_vip_guide_bg])43 button.configueTheme([ksTitleColorNormal: ksFFFFFF])44 button.titleLabel?.font &#x3D; 12.adaptor_Int.font_regular45 button.setTitle(&quot;会员畅用头像&quot;, for: .normal)46 button.titleEdgeInsets &#x3D; UIEdgeInsets(top: 0, left: 22.adaptor, bottom: 0, right: 0)47 return button48 &#125;()49 50 &#x2F;&#x2F;&#x2F;昵称51 private lazy var nickNameLabel: UILabel &#x3D; &#123;52 let label &#x3D; UILabel()53 label.configueTheme([ksTextColor: ks4A4A4A])54 label.font &#x3D; 20.adaptor_Int.font_hyzy_regular55 label.text &#x3D; &quot;昵称&quot;56 return label57 &#125;()5859 &#x2F;&#x2F;&#x2F;会员icon60 private lazy var vipIconImageView: UIImageView &#x3D; &#123;61 let imageView &#x3D; UIImageView()62 imageView.configueTheme([ksImage : ks_common_icon_vip_default])63 return imageView64 &#125;()65 66 &#x2F;&#x2F;&#x2F;获取头像按钮67 private lazy var chooseAvatarbutton: UIButton &#x3D; &#123;68 let button &#x3D; UIButton()69 button.configueTheme([ksBackgroundImageNormal: ks_vip_btn_re_kaitong])70 button.configueTheme([ksTitleColorNormal: ksFFFFFF])71 button.titleLabel?.font &#x3D; 17.adaptor_Int.font_hyzy_regular72 button.setTitle(&quot;获取头像&quot;, for: .normal)73 button.isHidden &#x3D; true74 return button75 &#125;()76 77 &#x2F;&#x2F;&#x2F;列表背景图78 private lazy var collectionBgImageView: UIImageView &#x3D; &#123;79 let imageView &#x3D; UIImageView()80 imageView.configueTheme([ksImage : ks_mine_pic_avatar_select_bg])81 return imageView82 &#125;()83 84 &#x2F;&#x2F;&#x2F;列表遮罩图85 private lazy var collectionMaskImageView: UIImageView &#x3D; &#123;86 let imageView &#x3D; UIImageView()87 imageView.configueTheme([ksImage : ks_mine_pic_avatar_select_mask])88 return imageView89 &#125;()90&#125;9192&#x2F;&#x2F; MARK: - Request93extension KSUserAvatarViewController &#123;94 95 &#x2F;&#x2F;&#x2F; 刷新96 override func configRefresh() &#123;97 super.configRefresh()98 viewModel.inputs.reload.onNext(false)99 &#125;100101 &#x2F;&#x2F;&#x2F; 加载更多102 override func configLoadMore() &#123;103 super.configLoadMore()104 viewModel.inputs.reload.onNext(true)105 &#125;106107 &#x2F;&#x2F;&#x2F; 自动触发网络请求108 override func configRequestData() &#123;109 super.configRequestData()110 111 viewModel.inputs.reload.onNext(false)112 113 viewModel.outputs.refreshState.subscribe(onNext: &#123; [weak self] (tuple) in114 guard let self &#x3D; self else &#123; return &#125;115 guard let hasMore &#x3D; tuple.hasMore else &#123;116 self.configEndRefresh()117 return118 &#125;119 if tuple.loadMore &#123;120 hasMore ? self.endFooterRefreshing() : self.endRefreshingWithNoMoreData()121 &#125; else &#123;122 self.endHeaderRefreshing()123 hasMore ? self.resetNoMoreData() : self.endRefreshingWithNoMoreData()124 &#125;125126 &#125;).disposed(by: disposeBag)127 &#125;128129 &#x2F;&#x2F;&#x2F; 手动触发网络请求，需要自己调用130 override func configRequestDataManual() &#123;131 super.configRequestDataManual()132 &#125;133&#125;134135&#x2F;&#x2F; MARK: - Override136extension KSUserAvatarViewController &#123;137 override func viewWillAppear(_ animated: Bool) &#123;138 super.viewWillAppear(animated)139 navigationController?.setNavigationBarHidden(true, animated: false)140 &#125;141 142 override func viewDidDisappear(_ animated: Bool) &#123;143 super.viewDidDisappear(animated)144 navigationController?.setNavigationBarHidden(false, animated: false)145 &#125;146 147 override func viewDidLoad() &#123;148 super.viewDidLoad()149 &#x2F;&#x2F;&#x2F;展示当前头像信息150 configWithUserInfo()151 &#125;152 153 override func configDefaultInit() &#123;154 super.configDefaultInit()155 showBackButton &#x3D; true156 if #available(iOS 11.0, *) &#123;157 collectionView.contentInsetAdjustmentBehavior &#x3D; .never158 &#125; else &#123;159 automaticallyAdjustsScrollViewInsets &#x3D; false160 &#125;161 collectionView.showsHorizontalScrollIndicator &#x3D; false162 collectionView.backgroundColor &#x3D; .clear163 164 if let layout &#x3D; collectionView.collectionViewLayout as? UICollectionViewFlowLayout &#123;165 layout.itemSize &#x3D; CGSize(width: Style.cellWidth, height: Style.cellHeight)166 layout.minimumLineSpacing &#x3D; Style.space167 layout.minimumInteritemSpacing &#x3D; 0168 layout.sectionInset &#x3D; .zero169 layout.scrollDirection &#x3D; .horizontal170 &#125;171 collectionView.isPagingEnabled &#x3D; false172 &#125;173 174 override func configSubviews() &#123;175 super.configSubviews()176 view.addSubviews(backgroundImageView,avatarView,vipGuideButton,nickNameLabel,vipIconImageView,chooseAvatarbutton,collectionBgImageView,collectionView,collectionMaskImageView)177178 &#125;179 180 override func configLayoutSubviews() &#123;181 super.configLayoutSubviews()182 183 backgroundImageView.snp.makeConstraints &#123; (make) in184 make.edges.equalTo(0)185 &#125;186 187 avatarView.snp.makeConstraints &#123; (make) in188 make.top.equalTo(52.adaptor)189 make.centerX.equalToSuperview()190 make.width.equalTo(104)191 make.height.equalTo(108)192 &#125;193194 vipGuideButton.snp.makeConstraints &#123; (make) in195 make.top.equalTo(20.adaptor)196 make.right.equalTo(-20.adaptor)197 make.width.equalTo(128.adaptor)198 make.height.equalTo(32.5.adaptor)199 &#125;200201 nickNameLabel.snp.makeConstraints &#123; (make) in202 make.top.equalTo(avatarView.snp.bottom).offset(10)203 make.centerX.equalTo(avatarView)204 &#125;205206 vipIconImageView.snp.makeConstraints &#123; (make) in207 make.left.equalTo(nickNameLabel.snp.right).offset(2.adaptor)208 make.width.height.equalTo(24.adaptor)209 make.centerY.equalTo(nickNameLabel)210 &#125;211212 chooseAvatarbutton.snp.makeConstraints &#123; (make) in213 make.top.equalTo(nickNameLabel.snp.bottom).offset(14.adaptor)214 make.width.equalTo(131.adaptor)215 make.height.equalTo(47.5.adaptor)216 make.centerX.equalToSuperview()217 &#125;218219 collectionBgImageView.snp.makeConstraints &#123; (make) in220 make.left.right.bottom.equalTo(0)221 make.height.equalTo(Style.cellHeight)222 &#125;223 224 collectionView.snp.makeConstraints &#123; make in225 make.edges.equalTo(collectionBgImageView)226 &#125;227 228 collectionMaskImageView.snp.makeConstraints &#123; make in229 make.edges.equalTo(collectionBgImageView)230 &#125;231 &#125;232 233 override func configBindSubviews() &#123;234 super.configBindSubviews()235 collectionView.rx.setDelegate(self).disposed(by: disposeBag)236 collectionView.registerReusableCell(ofType: KSUserAvatarListCell.self)237 &#125;238 239 override func configBind() &#123;240 super.configBind()241 &#x2F;&#x2F; 1. 信号创建242 let selectedType &#x3D; Driver.zip(collectionView.rx.itemSelected.asDriver(), collectionView.rx.modelSelected(KSUserAvatarListCellViewModel.self).asDriver())243 let outputs &#x3D; viewModel.transform(inputs: KSUserAvatarViewModel.Inputs(selectedType: selectedType))244 245 &#x2F;&#x2F; 2. 信号绑定246 let dataSource &#x3D; RxCollectionViewSectionedReloadDataSource&lt;SectionModel&lt;String, KSUserAvatarListCellViewModel&gt;&gt;(247 configureCell: &#123; (dataSource, collectionView, indexPath, item) in248 let cell &#x3D; collectionView.dequeueReusableCell(ofType: KSUserAvatarListCell.self, at: indexPath)249 cell.cellViewModel &#x3D; item250 return cell251 &#125; 252 )253 254 outputs.dataArray.asDriver(onErrorJustReturn: []).drive(collectionView.rx.items(dataSource: dataSource)).disposed(by: disposeBag)255 256 outputs.dataArray.subscribe(onNext: &#123; [weak self] (_) in257 guard let self &#x3D; self, !self.viewModel.outputs.dataArray.value.isEmpty, let section &#x3D; self.viewModel.outputs.dataArray.value.objectAt(0) else &#123; return &#125;258259 &#x2F;&#x2F;&#x2F;取用户账户信息260 let headImgId &#x3D; KSBusinessUserManager.default.fetchCurrentUserinfo()?.headImgId261262 for (pageIndex,cellViewModel) in section.items.enumerated() &#123;263 if headImgId &#x3D;&#x3D; cellViewModel.outputs.model.value?.virtualId &#123;264 cellViewModel.outputs.isSelected.accept(true)265 self.chooseAvatarbutton.isHidden &#x3D; true266 self.viewModel.outputs.headImgId.accept(headImgId ?? &quot;&quot;)267 268 &#x2F;&#x2F;&#x2F;更改collectionviewcell位置269 DispatchQueue.main.asyncAfter(deadline: .now() + 0.25) &#123;270 if self.collectionView.contentSize.height &#x3D;&#x3D; 0 &#123; return &#125;271 self.collectionView.layoutIfNeeded()272 self.collectionView.scrollToItem(at: IndexPath(item: pageIndex, section: 0), at: .centeredVertically, animated: false)273 &#125;274 break275 &#125;276 &#125;277 278 &#125;).disposed(by: disposeBag)279 280 viewModel.inputs.selectedType.throttle(.seconds(1), latest: false).drive(onNext: &#123; [weak self] tuple in281 guard let self &#x3D; self , let section &#x3D; self.viewModel.outputs.dataArray.value.objectAt(0) else &#123;return&#125;282 283 let cellViewModel &#x3D; section.items.objectAt(tuple.0.item)284 285 &#x2F;&#x2F;&#x2F;设置头像286 self.avatarView.updateAvatar(url: cellViewModel?.outputs.model.value?.backGroundImg ?? &quot;&quot;)287 288 &#x2F;&#x2F;&#x2F;判断是正在使用的头像289 if cellViewModel?.outputs.model.value?.virtualId &#x3D;&#x3D; self.viewModel.outputs.headImgId.value &#123;290 self.chooseAvatarbutton.isHidden &#x3D; true291 &#125; else &#123;292 self.chooseAvatarbutton.isHidden &#x3D; false293 &#125;294295 &#125;).disposed(by: disposeBag)296 297 &#x2F;&#x2F;&#x2F;头像更新成功298 viewModel.outputs.updateAvatarSuccessed.subscribe(onNext: &#123; [weak self] _ in299 guard let self &#x3D; self else &#123;return&#125;300 self.chooseAvatarbutton.isHidden &#x3D; true301 self.avatarView.updateAvatar(url: self.viewModel.outputs.selectedModel.value?.backGroundImg ?? &quot;&quot;)302303 KSToast.makeToast(&quot;头像设置成功啦~&quot;, position: .center)304 &#125;).disposed(by: disposeBag)305 306 &#x2F;&#x2F;&#x2F;会员引导点击事件307 vipGuideButton.rx.tap.throttle(.seconds(1), latest: false, scheduler: MainScheduler.instance).subscribe(onNext: &#123; _ in308 KSPageJumpCenterTool.linkToWithPage(&quot;RNMemberPurchase&quot;)309 &#125;).disposed(by: disposeBag)310 311 &#x2F;&#x2F;&#x2F;修改头像事件312 chooseAvatarbutton.rx.tap.throttle(.seconds(1), latest: false, scheduler: MainScheduler.instance).subscribe(onNext: &#123; [weak self] _ in313 guard let self &#x3D; self else &#123;return&#125;314 guard let model &#x3D; self.viewModel.outputs.selectedModel.value else &#123;315 &#x2F;&#x2F;&#x2F;未选择头像316 return317 &#125;318 319 let vipStatus &#x3D; KSVipBusinessManager.default.vipStatus()320 if model.isShowMemberIcon &#x3D;&#x3D; true &amp;&amp; vipStatus !&#x3D; .normal &#123;321 &#x2F;&#x2F;&#x2F;非会员身份选择会员头像 需要弹出开通会员引导弹窗322 &#x2F;&#x2F;&#x2F;请求会员广告信息323 self.vipAdverManager.configUserVipAdver(3)324 &#125;325 self.viewModel.inputs.updateAvatar.onNext(())326327 &#125;).disposed(by: disposeBag)328 &#125;329&#125;330331&#x2F;&#x2F; MARK: - Private332333extension KSUserAvatarViewController &#123;334 &#x2F;&#x2F;&#x2F;进来页面展示头像信息335 private func configWithUserInfo() &#123;336 guard let userInfo &#x3D; KSBusinessUserManager.default.fetchCurrentUserinfo() else &#123;337 return338 &#125;339 avatarView.updateAvatar(url: userInfo.headImgUrl)340 341 nickNameLabel.text &#x3D; userInfo.nickname342 343 let vipStatus &#x3D; KSVipBusinessManager.default.vipStatus()344 if vipStatus &#x3D;&#x3D; .unknow &#123;345 &#x2F;&#x2F;&#x2F;未开通346 vipGuideButton.isHidden &#x3D; false347 vipIconImageView.isHidden &#x3D; true348349 &#125; else if vipStatus &#x3D;&#x3D; .normal &#123;350 &#x2F;&#x2F;&#x2F;已开通351 vipGuideButton.isHidden &#x3D; true352 vipIconImageView.isHidden &#x3D; false353 vipIconImageView.configueTheme([ksImage : ks_common_icon_vip_default])354355 &#125; else &#123;356 &#x2F;&#x2F;&#x2F;会员失效357 vipGuideButton.isHidden &#x3D; true358 vipIconImageView.isHidden &#x3D; false359 vipIconImageView.configueTheme([ksImage : ks_common_icon_vip_expired])360 &#125;361 &#125;362&#125;363364&#x2F;&#x2F; MARK: - UICollectionViewDelegate365extension KSUserAvatarViewController: UICollectionViewDelegate, UICollectionViewDelegateFlowLayout &#123;366&#125; KSUserAvatarViewModel1import UIKit2import RxSwift3import RxCocoa4import RxDataSources56class KSUserAvatarViewModel: KSBaseViewModel, KSBaseViewModelProtocol &#123;7 8 private let disposeBag &#x3D; DisposeBag()9 private let provider &#x3D; KSNetworkCommonManager.provider(KSUserAvatarAPI.self, stub: false, log: true)10 private var page &#x3D; 111 12 &#x2F;&#x2F;&#x2F; MARK: - 信号13 &#x2F;&#x2F;&#x2F; 输入源 &lt;订阅&gt;14 public var inputs &#x3D; Inputs()15 public struct Inputs &#123;16 &#x2F;&#x2F;&#x2F; 刷新列表17 var reload: PublishSubject&lt;Bool&gt; &#x3D; PublishSubject&lt;Bool&gt;()18 &#x2F;&#x2F;&#x2F; 更新头像请求19 var updateAvatar: PublishSubject&lt;Void&gt; &#x3D; PublishSubject&lt;Void&gt;()20 &#x2F;&#x2F;&#x2F; cell点击21 var selectedType: Driver&lt;(IndexPath, KSUserAvatarListCellViewModel)&gt; &#x3D; Driver.empty()22 &#125;23 24 &#x2F;&#x2F;&#x2F; 输出源 &lt;发送&gt;25 public var outputs &#x3D; Outputs()26 public struct Outputs &#123;27 &#x2F;&#x2F;&#x2F; 加载状态28 var loadingState: PublishSubject&lt;LoadingState&gt; &#x3D; PublishSubject&lt;LoadingState&gt;()29 &#x2F;&#x2F;&#x2F; 刷新状态30 var refreshState: PublishSubject&lt;(loadMore: Bool, hasMore: Bool?)&gt; &#x3D; PublishSubject&lt;(loadMore: Bool, hasMore: Bool?)&gt;()31 &#x2F;&#x2F;&#x2F; 更新头像成功32 var updateAvatarSuccessed: PublishSubject&lt;Void&gt; &#x3D; PublishSubject&lt;Void&gt;()3334 &#x2F;&#x2F;&#x2F; 数据源 （常用BehaviorRelay，方便value操作，并通过accept发出信号）35 var dataArray: BehaviorRelay&lt;[SectionModel&lt;String, KSUserAvatarListCellViewModel&gt;]&gt; &#x3D; BehaviorRelay(value: [])36 &#x2F;&#x2F;&#x2F;当前的头像id37 var headImgId: BehaviorRelay&lt;String&gt; &#x3D; BehaviorRelay(value: &quot;&quot;)38 &#x2F;&#x2F;&#x2F;当前选中的头像model39 var selectedModel: BehaviorRelay&lt;KSUserAvatarModel.Item?&gt; &#x3D; BehaviorRelay(value: nil)40 &#125;41 42 &#x2F;&#x2F;&#x2F; 信号转换43 public func transform(inputs: Inputs) -&gt; Outputs &#123;44 self.inputs &#x3D; inputs45 46 &#x2F;&#x2F;&#x2F; 请求头像列表网络请求47 inputs.reload.subscribe(onNext: &#123; [weak self] loadMore in48 self?.requestList(loadMore)49 &#125;).disposed(by: disposeBag)5051 &#x2F;&#x2F;&#x2F;更新头像网络请求52 inputs.updateAvatar.subscribe(onNext: &#123; [weak self] _ in53 guard let self &#x3D; self else &#123;return&#125;54 let headImgUrl &#x3D; self.outputs.selectedModel.value?.backGroundImg55 let headImgId &#x3D; self.outputs.selectedModel.value?.virtualId56 self.requestUpdateAvatar(headImgUrl ?? &quot;&quot;, headImgId ?? &quot;&quot;)5758 &#125;).disposed(by: disposeBag)59 60 &#x2F;&#x2F;&#x2F; 选择cell61 inputs.selectedType.drive(onNext: &#123; [weak self] tuple in62 guard let self &#x3D; self , let section &#x3D; self.outputs.dataArray.value.objectAt(0) else &#123;return&#125;63 64 &#x2F;&#x2F;&#x2F;记录选中的头像信息model65 self.outputs.selectedModel.accept(section.items.objectAt(tuple.0.item)?.outputs.model.value)66 67 for (i, cellViewModel) in section.items.enumerated() &#123;68 &#x2F;&#x2F;&#x2F;tuple元祖 ( IndexPath, KSUserAvatarListCellViewModel )69 cellViewModel.outputs.isSelected.accept(tuple.0.item &#x3D;&#x3D; i)70 &#125; 71 &#125;).disposed(by: disposeBag)72 73 &#x2F;&#x2F;&#x2F; viewModel -&gt; 信号74 outputs.dataArray.subscribe(onNext: &#123; (_) in75 76 &#125;).disposed(by: disposeBag)77 78 return outputs79 &#125;80&#125;8182extension KSUserAvatarViewModel &#123;83 84 &#x2F;&#x2F;&#x2F; 列表数据请求85 private func requestList(_ loadMore: Bool) &#123;86 self.outputs.loadingState.onNext(.loading)87 let tempPage &#x3D; loadMore ? page + 1 : 18889 KSNetworkCommonManager.default.requestWithRxSwift(provider: provider, target: KSUserAvatarAPI.list(page: page), dataType: KSResponse&lt;KSUserAvatarModel&gt;.self).subscribe(onNext: &#123; [weak self] (result) in90 guard let self &#x3D; self else &#123; return &#125;91 guard let data &#x3D; result.data, result.code &#x3D;&#x3D; KSNetworkCommonConstants.Code.codeSuccess else &#123;92 self.outputs.loadingState.onNext(.fail)93 self.outputs.refreshState.onNext((loadMore: loadMore, hasMore: nil))94 return95 &#125;96 97 self.page &#x3D; tempPage98 self.outputs.loadingState.onNext(.success)99 self.outputs.refreshState.onNext((loadMore: loadMore, hasMore: !data.list.isEmpty))100 &#x2F;&#x2F;&#x2F;配置数据源101 self.configDataArray(loadMore, data)102103 &#125;, onError: &#123; [weak self] (error) in104 guard let self &#x3D; self else &#123; return &#125;105 self.outputs.loadingState.onNext(.fail)106 self.outputs.refreshState.onNext((loadMore: loadMore, hasMore: nil))107108 &#125;).disposed(by: disposeBag)109 &#125;110 111 &#x2F;&#x2F;&#x2F;更新头像接口请求112 private func requestUpdateAvatar(_ headImgUrl: String, _ headImgId: String) &#123;113 KSNetworkCommonManager.default.requestWithRxSwift(provider: provider, target: KSUserAvatarAPI.updateAvatar(headImgUrl: headImgUrl, headImgId: headImgId), dataType: KSResponse&lt;KSUserAvatarModel&gt;.self).subscribe(onNext: &#123; [weak self] (result) in114 guard let self &#x3D; self else &#123; return &#125;115 guard result.code &#x3D;&#x3D; KSNetworkCommonConstants.Code.codeSuccess else &#123;116 KSToast.makeToast(result.message, position: .center)117 return118 &#125;119 &#x2F;&#x2F;&#x2F;记录更新完的头像id120 self.outputs.headImgId.accept(headImgId)121 self.outputs.updateAvatarSuccessed.onNext(())122123 &#125;, onError: &#123; (error) in124125 &#125;).disposed(by: disposeBag)126 &#125;127 128 &#x2F;&#x2F;&#x2F;配置列表数据源129 private func configDataArray(_ loadMore: Bool ,_ model: KSUserAvatarModel) &#123;130 DispatchQueue.global().async &#123;131 &#x2F;&#x2F;&#x2F; 1. 列表数据源132 var dataArray: [SectionModel&lt;String, KSUserAvatarListCellViewModel&gt;] &#x3D; []133 &#x2F;&#x2F;&#x2F; 2. cellViewModel数组134 var items: [KSUserAvatarListCellViewModel] &#x3D; []135 136 for listModel in model.list &#123;137 items.append(KSUserAvatarListCellViewModel(listModel))138 &#125;139140 var sectionModel: SectionModel&lt;String, KSUserAvatarListCellViewModel&gt; &#x3D; SectionModel(model: &quot;&quot;, items: items)141 sectionModel.items &#x3D; items142 dataArray.append(sectionModel)143144 DispatchQueue.main.async &#123;145 if loadMore &#123;146 &#x2F;&#x2F;&#x2F;加载147 self.outputs.dataArray.accept(self.outputs.dataArray.value + dataArray)148 &#125; else &#123;149 &#x2F;&#x2F;&#x2F;刷新150 self.outputs.dataArray.accept(dataArray)151 &#125;152 &#125;153 &#125;154 &#125;155 156 func test() &#123;157 let text &#x3D; &quot;&quot;&quot;158 &#123;159 &quot;list&quot;: [160 &#123;161 &quot;backGroundImg&quot;: &quot;http:&#x2F;&#x2F;3a3d0ca5-e784-437b-b3af-8f779cf275a0_info.png&quot;,162 &quot;virtualId&quot;: &quot;98124124&quot;,163 &quot;exchangeType&quot;: &quot;free&quot;,164 &quot;isShowNewIcon&quot;: true,165 &quot;isShowMemberIcon&quot;: false166 &#125;167 ]168 &#125;169 &quot;&quot;&quot;170 guard let model &#x3D; KSUserAvatarModel(JSONString: text) else &#123;171 return172 &#125;173 self.configDataArray(false, model)174 &#125;175&#125;","categories":[{"name":"RxSwift","slug":"RxSwift","permalink":"http://yoursite.com/categories/RxSwift/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"block分析","slug":"block分析","date":"2020-07-03T06:56:33.000Z","updated":"2020-07-03T07:12:51.000Z","comments":true,"path":"2020/2020-07-03-14:56:33/","link":"","permalink":"http://yoursite.com/2020/2020-07-03-14:56:33/","excerpt":"Block 内存管理，__block修饰变量值的原理","text":"Block 内存管理，__block修饰变量值的原理 首先看一下block 的结构体： 1struct __block__testBlock_block_impl_0 &#123;2 struct __block_impl impl;3 struct __block__testBlock_block_desc_0* Desc;4 int i;5 __unsafe_unretained id unsafe_obj;6 __strong id strong_obj;7 int *static_int;8 __block__testBlock_block_impl_0(void *fp, struct __block__testBlock_block_desc_0 *desc, int _i, __unsafe_unretained id _unsafe_obj, __strong id _strong_obj, int *_static_int, int flags&#x3D;0) : i(_i), unsafe_obj(_unsafe_obj), strong_obj(_strong_obj), static_int(_static_int) &#123;9 impl.isa &#x3D; &amp;_NSConcreteStackBlock;10 impl.Flags &#x3D; flags;11 impl.FuncPtr &#x3D; fp;12 Desc &#x3D; desc;13 &#125;14&#125;; impl.isa = &amp;_NSConcreteStackBlock;用来标识是哪种类型的 block 三种block类型： 11. _NSConcreteGlobalBlock &#x2F;&#x2F; 全局block22. _NSConcreteStackBlock &#x2F;&#x2F; 栈block33. _NSConcreteMallocBlock &#x2F;&#x2F; 堆 block block 的 copy 操作,修改值的原理，__forwarding 作用 blcok类型 原位置 copy之后的结果 _NSConcreteStackBlock 栈 堆 _NSConcreteStackBlock 数据区 不做任何事情 _NSConcreteMallocBlock 堆 增加引用计数 栈block在作用域结束之后，对应的block也会销毁 当在栈上对block进行copy之后，会在堆上copy一份，当栈上变量作用于结束之后，栈block 会销毁，但是堆上会存在。 所以在mrc对blockcopy之后，容易造成内存泄漏，因为堆上没有释放. 我们的栈上 block 有一个 __Block 变量，同时还有个__forwarding 指针，指向他自己，当进行copy之后，会在堆上也有一份，同时也会有， __Block变量和 __forwarding 指针，这里面的__forwarding指针的用途是什么呢？当进行copy之后，栈上的__forwarding指针指向堆上的 __Block变量,而堆上的__forwarding指针，也指向自身的__Block变量,所以当我们要修改一个值得时候用 __Block指针来修饰,原因是，这时候已经将栈上面的block，copy到了堆上面，当我们修改变量的值得时候，其实就是通过栈上面的那个__forwarding指针找到堆上面的__block变量，然后修改堆上面的__Block修饰的变量的值，如果我们这个block被成员变量或者其他地方持有的话，那么实际上就是通过堆上面自身的变量的值，所以可以总结，当我们的栈block经过copy之后，堆上面会有一份，都是通过 __forwarding指针，找到__block变量，然后修改他的值。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS 内存布局&内存管理方案","slug":"iOS-内存布局-内存管理方案","date":"2020-07-02T10:45:13.000Z","updated":"2020-07-03T02:31:48.000Z","comments":true,"path":"2020/2020-07-02-18:45:13/","link":"","permalink":"http://yoursite.com/2020/2020-07-02-18:45:13/","excerpt":"内存布局-五大区","text":"内存布局-五大区 栈区 0x7 创建临时变量时由编译器自动分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编 译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。 堆区 0x6 那些由 new alloc 创建的对象所分配的内存块，它们的释放系统不会主动去管，由我们的开发者去告诉系统什么时候释放这块内存(一个对象引用计数为0是系统就会回销毁该内存区域对象)。一般一个 new 就要对应一个 release。在ARC下编译器会自动在合适位置为OC对象添加release操作。会在当前线程Runloop退出或休眠时销毁这些对象，MRC则需程序员手动释放。堆可以动态地扩展和收缩。 静态区(未初始化数据).bss 程序运行过程内存的数据一直存在，程序结束后由系统释放 常量区(已初始化数据).data 专门用于存放常量，程序结束后由系统释放 代码区 用于存放程序运行时的代码，代码会被编译成二进制存进内存的程序代码区 内存管理方案TaggedPointer通常我们创建对象，对象存储在堆中，对象的指针存储在栈中，如果我们要找到这个对象，就需要先在栈中，找到指针地址，然后根据指针地址找到在堆中的对象。这个过程比较繁琐，当存储的对象只是一个很小的东西，比如一个字符串，一个数字。去走这么一个繁琐的过程，无非是耗费性能的，所以苹果就搞出了TaggedPointer这么一个东西。 TaggedPointer是苹果为了解决32位CPU到64位CPU的转变带来的内存占用和效率问题，针对NSNumber、NSDate以及部分NSString的内存优化方案。 Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。 Tagged Pointer指针中包含了当前对象的地址、类型、具体数值。因此Tagged Pointer指针在内存读取上有着3倍的效率，创建时比普通需要malloc跟free的类型快106倍。 这里有对TaggedPointer进行详细介绍 问题为什么第二个for会崩溃？ 1dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);2 dispatch_async(queue, ^&#123;3 for (int i &#x3D; 0 ; i&lt;1000000; i++) &#123;4 self.str &#x3D; @&quot;abcd&quot;;5 &#125;6 &#125;);7 dispatch_async(queue, ^&#123;8 for (int i &#x3D; 0 ; i&lt;1000000; i++) &#123;9 self.str &#x3D; [NSString stringWithFormat:@&quot;adfalkdjfldkasjflakjsdkflasf-- %d&quot;,I];10 &#125;11 &#125;); 答：taggedpointer。在setproperty函数中，执行了objc_release(id obj)。由于大量的循环，导致了线程问题，使引用计数&lt;=-1。但是由于第一个循环中的obj是taggedpointer类型的string，会直接return obj，并不会release。但是这里release，retain的时候咋办呢，引用计数是一直往上增吗？并不是，在objc_retain(id obj)中，同样判断了obj-&gt;isTaggedPointer，如果是true，就直接return obj。 NONPOINTER_ISANSObject继承关系：NSObject -&gt; Class -&gt; objc_class -&gt; objc_object -&gt; isa_t 1union isa_t &#123;2 isa_t() &#123; &#125;3 isa_t(uintptr_t value) : bits(value) &#123; &#125;45 Class cls;6 uintptr_t bits;7#if defined(ISA_BITFIELD)8 struct &#123;9 ISA_BITFIELD; &#x2F;&#x2F; defined in isa.h10 &#125;;11#endif12&#125;; isa_t是联合体，然后重点看ISA_BITFIELD， 参数解释 nonpointer:表示是否对 isa 指针开启指针优化 ， 0:纯isa指针，1:不止是类对象地址,isa 中包含了类信息、对象的引用计数等。 has_assoc:关联对象标志位，0没有，1存在。 has_cxx_dtor:该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更更快的释放对象。 shiftcls:存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位⽤来存储类指针的值。 magic:用于调试器判断当前对象是真的对象还是没有初始化的空间 。 weakly_referenced:标志对象是否被指向或者曾经指向⼀一个 ARC 的弱变量，没有弱引用的对象可以更快释放。 deallocating:标志对象是否正在释放内存。 has_sidetable_rc:是否有用到散列表，当对象引⽤计数大于 10 时，则需要借⽤该变量存储进位。 extra_rc:当表示该对象的引用计数值，实际上是引用计数值减 1。例如，如果对象的引用计数为 10，那么 extra_rc 为 9。例：在x86_64(mac)的架构下，如果引用计数大于 255，引用计数将会发生溢出。 溢出时，则需要将has_sidetable_rc标记为1，将会将拿出2的7次方(128，就是上面的RC_HALF)放入散列表(sidetable)","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Explain +load and +initlalize","slug":"Explain-load-and-initlalize","date":"2020-06-02T03:34:34.000Z","updated":"2020-07-02T10:51:32.000Z","comments":true,"path":"2020/2020-06-02-11:34:34/","link":"","permalink":"http://yoursite.com/2020/2020-06-02-11:34:34/","excerpt":"Explain +load and +initlalize","text":"Explain +load and +initlalize + (void)load;Apple文档是这样描述的： Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading. 当类（Class）或者类别（Category）加入Runtime中时调用。实现该方法，可以在加载时做一些类特有的操作。 Discussion The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond. The order of initialization is as follows: All initializers in any framework you link to.调用所有的Framework中的初始化方法 All +load methods in your image.调用所有的+load方法 All C++ static initializers and C/C++ attribute(constructor) functions in your image.调用C++的静态初始化方及C/C++中的attribute(constructor)函数 All initializers in frameworks that link to you.调用所有链接到目标文件的framework中的初始化方法 In addition: A class’s +load method is called after all of its superclasses’ +load methods.一个类的+load方法在其父类的+load方法后调用 A category +load method is called after the class’s own +load method.一个Category的+load方法在被其扩展的类的自有+load方法后调用 In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.在+load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的+load方法可能尚未被调用。 文档地址 load函数调用特点如下:当类被引用进项目的时候就会执行load函数(在main函数开始执行之前）,与这个类是否被用到无关,每个类的load函数只会自动调用一次.由于load函数是系统自动加载的，因此不需要调用父类的load函数，否则父类的load函数会多次执行。 当父类和子类都实现load函数时,父类的load方法执行顺序要优先于子类 类中的load方法执行顺序要优先于类别(Category) 当有多个类别(Category)都实现了load方法,这几个load方法都会执行,但执行顺序不确定(其执行顺序与类别在Compile Sources中出现的顺序一致) 当然当有多个不同的类的时候,每个类load 执行顺序与其在Compile Sources出现的顺序一致 + (void)initialize;Apple文档是这样描述的： Initializes the class before it receives its first message. 在这个类接收第一条消息之前调用。 Discussion The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses. Runtime在一个程序中每一个类的一个程序中发送一个初始化一次，或是从它继承的任何类中，都是在程序中发送第一条消息。（因此，当该类不使用时，该方法可能永远不会被调用。）运行时发送一个线程安全的方式初始化消息。父类的调用一定在子类之前。 文档地址 initialize函数调用特点如下:initialize在类或者其子类的第一个方法被调用前调用。即使类文件被引用进项目,但是没有使用,initialize不会被调用。由于是系统自动调用，也不需要再调用 [super initialize] ，否则父类的initialize会被多次执行。假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。 父类的initialize方法会比子类先执行 当子类未实现initialize方法时,会调用父类initialize方法,子类实现initialize方法时,会覆盖父类initialize方法. 当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个(会执行Compile Sources 列表中最后一个Category 的initialize方法) 我们在Teacher(继承Person).m中不实现initialize方法： 1&#x2F;&#x2F;In Person.m2+(void)initialize3&#123;4 NSLog(@&quot;%s&quot;,__FUNCTION__);5&#125;67&#x2F;&#x2F;In Teacher.m(继承自Person)89Teacher.m中不实现initialize方法 我们调用下Teacher的new方法,运行： 1[Teacher new]; 运行结果： 12017-05-04 14:06:45.051 LoadAndInitializeExample[29238:912579] +[Person initialize]22017-05-04 14:06:45.051 LoadAndInitializeExample[29238:912579] +[Person initialize] 运行后发现父类的initialize方法竟然调用了两次：可见当子类未实现initialize方法,会调用父类initialize方法.但为什么会打印2次呢?我的理解:子类不实现initialize方法，会把继承父类的initialize方法并调用一遍。在此之前,父类初始化时,会先调用一遍自己initialize方法.所以出现2遍,所以为了防止父类initialize中代码多次执行,我们应该这样写: 1&#x2F;&#x2F;In Person.m2+(void)initialize3&#123;4 if(self &#x3D;&#x3D; [Person class])5 &#123;6 NSLog(@&quot;%s&quot;,__FUNCTION__);7 &#125;8&#125; 下面我们在 Teacher.m中实现initialize方法 1&#x2F;&#x2F;In Person.m2+(void)initialize3&#123;4 NSLog(@&quot;%s&quot;,__FUNCTION__);5&#125;67&#x2F;&#x2F;In Teacher.m(继承自Person)8+(void)initialize9&#123;10 NSLog(@&quot;%s&quot;,__FUNCTION__);11&#125; 同样调用Teacher 的new方法,运行： 1[Teacher new]; 运行结果: 12017-05-04 14:07:45.051 LoadAndInitializeExample[29238:912579] +[Person initialize]22017-05-04 14:07:45.051 LoadAndInitializeExample[29238:912579] +[Teacher initialize] 可以看到 当子类实现initialize方法后,会覆盖父类initialize方法,这一点和继承思想一样。 什么情况下使用： +load由于调用load方法时的环境很不安全，我们应该尽量减少load方法的逻辑。另一个原因是load方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在load方法中 load很常见的一个使用场景,交换两个方法的实现： 1&#x2F;&#x2F;摘自MJRefresh2+ (void)load3&#123;4 [self exchangeInstanceMethod1:@selector(reloadData) method2:@selector(mj_reloadData)];5 [self exchangeInstanceMethod1:@selector(reloadRowsAtIndexPaths:withRowAnimation:) method2:@selector(mj_reloadRowsAtIndexPaths:withRowAnimation:)];6 [self exchangeInstanceMethod1:@selector(deleteRowsAtIndexPaths:withRowAnimation:) method2:@selector(mj_deleteRowsAtIndexPaths:withRowAnimation:)];7 [self exchangeInstanceMethod1:@selector(insertRowsAtIndexPaths:withRowAnimation:) method2:@selector(mj_insertRowsAtIndexPaths:withRowAnimation:)];8 [self exchangeInstanceMethod1:@selector(reloadSections:withRowAnimation:) method2:@selector(mj_reloadSections:withRowAnimation:)];9 [self exchangeInstanceMethod1:@selector(deleteSections:withRowAnimation:) method2:@selector(mj_deleteSections:withRowAnimation:)];10 [self exchangeInstanceMethod1:@selector(insertSections:withRowAnimation:) method2:@selector(mj_insertSections:withRowAnimation:)];11&#125;1213+ (void)exchangeInstanceMethod1:(SEL)method1 method2:(SEL)method214&#123;15 method_exchangeImplementations(class_getInstanceMethod(self, method1), class_getInstanceMethod(self, method2));16&#125; ####+initialize initialize方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如NSMutableArray这种类型的实例化依赖于runtime的消息发送，所以显然无法在编译器初始化： 12&#x2F;&#x2F; In Person.m3&#x2F;&#x2F; int类型可以在编译期赋值4static int someNumber &#x3D; 0; 5static NSMutableArray *someArray;6+ (void)initialize &#123;7 if (self &#x3D;&#x3D; [Person class]) &#123;8 &#x2F;&#x2F; 不方便编译期复制的对象在这里赋值9 someArray &#x3D; [[NSMutableArray alloc] init];10 &#125;11&#125; 总结：load和initialize的共同点1.如果父类和子类都被调用,父类的调用一定在子类之前； +load方法要点 当类被引用进项目的时候就会执行load函数(在main函数开始执行之前）,与这个类是否被用到无关,每个类的load函数只会自动调用一次.由于load函数是系统自动加载的，因此不需要再调用[super load]，否则父类的load函数会多次执行。 当父类和子类都实现load函数时,父类的load方法执行顺序要优先于子类 类中的load方法执行顺序要优先于类别(Category) 当有多个类别(Category)都实现了load方法,这几个load方法都会执行,但执行顺序不确定(其执行顺序与类别在Compile Sources中出现的顺序一致) 当然当有多个不同的类的时候,每个类load 执行顺序与其在Compile Sources出现的顺序一致 注意: load调用时机比较早,当load调用时,其他类可能还没加载完成,运行环境不安全. load方法是线程安全的，它使用了锁，我们应该避免线程阻塞在load方法. +initialize方法要点 initialize在类或者其子类的第一个方法被调用前调用。即使类文件被引用进项目,但是没有使用,initialize不会被调用。由于是系统自动调用，也不需要显式的调用父类的initialize，否则父类的initialize会被多次执行。假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。 父类的initialize方法会比子类先执行 当子类未实现initialize方法时,会调用父类initialize方法,子类实现initialize方法时,会覆盖父类initialize方法. 当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个(会执行Compile Sources 列表中最后一个Category 的initialize方法) 注意: 在initialize方法收到调用时,运行环境基本健全。 initialize内部也使用了锁，所以是线程安全的。但同时要避免阻塞线程，不要再使用锁","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"SEL和Method和IMP详解","slug":"SEL和Method和IMP详解","date":"2020-06-01T03:45:31.000Z","updated":"2021-03-03T06:32:20.007Z","comments":true,"path":"2020/2020-06-01-11:45:31/","link":"","permalink":"http://yoursite.com/2020/2020-06-01-11:45:31/","excerpt":"SEL和Method和IMP分别说下，再谈下对IMP的理解","text":"SEL和Method和IMP分别说下，再谈下对IMP的理解 在 Objective-C 中，SEL/selector，Method 和 implementation(IMP) 都是 Runtime 的组成部分。在实际开发中它们常常可以相互转换来处理消息的发送。 SEL先看看定义： 1Objc.h2&#x2F;&#x2F;&#x2F; An opaque type that represents a method selector.代表一个方法的不透明类型3typedef struct objc_selector *SEL; Selector 1@property SEL selector; 要先说明下selector和SEL的关系，我在写本文的时候，其实搜索的是selector，直到我看到了selector的定义，才发现我理解一直不对。 在文档中，selector的定义都是这样声明，也就是说：selector是SEL的一个实例，只是在iOS中，selector的使用是如此的频繁，我们才会把他当成一个概念。 selector怎么理解呢？我们可以想想股票，比如市场上有如此多公司在纳斯达克上市，而且他们的名字又非常的长，或者有些公司的名称也是相似的，都是**有限公司。那当市场去指定一个股票的时候，效率会非常低，当你着急想买股票的时候，你会跟你的经纪人说：“hi，peter，给我买一百股Tuniu limited liability company的股票吗？”，也许等你说完，经纪人输入完，市场就变化了，所以纳斯达克通常用代码，比如“TOUR”.这里的selector有类似的作用，就是让我们能够快速找到对应的函数。 selector翻译成中文叫做选择子或者选择器，选择子代表方法在 Runtime 期间的标识符。为 SEL 类型，虽然 SEL 是 objc_selector 结构体指针，但实际上它只是一个 C 字符串。在类加载的时候，编译器会生成与方法相对应的选择子，并注册到 Objective-C 的 Runtime 运行系统。 常见的有两种方式来获取/创建选择子: 1SEL selA &#x3D; @selector(setString:);2SEL selB &#x3D; sel_registerName(&quot;setString:&quot;); 从 sel_getName() 方法的源码可以看出 SEL 和 const char * 是可以相互转化的： 1const char *sel_getName(SEL sel) &#123;2 return sel ? (const char *)sel : &quot;&lt;null selector&gt;&quot;;3&#125; 如果将 selA 和 selB 强转为为 const char *: 1(lldb) p (const char *)$22(const char *) $3 &#x3D; 0x00007fff9a3794b5 &quot;setString:&quot;3(lldb) p (const char *)$14(const char *) $4 &#x3D; 0x00007fff9a3794b5 &quot;setString:&quot;5(lldb) 上面的结果可以看出，selA 和 selB 指向相同的地址，代表同一个字符串。 如果某个类实现了 setString：方法，那么以上两个选择子传入 respondsToSelector() 方法返回的结果都将为 YES。 不同类中相同名字的方法所对应的方法选择子是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择子。 Implementation(IMP): 看一下 IMP 的定义： 1&#x2F;&#x2F;&#x2F; A pointer to the function of a method implementation. 指向一个方法实现的指针2typedef id (*IMP)(id, SEL, ...); 3#endif 代表函数指针，即函数执行的入口。该函数使用标准的 C 调用。第一个参数指向 self（它代表当前类实例的地址，如果是类则指向的是它的元类），作为消息的接受者；第二个参数代表方法的选择子；… 代表可选参数，前面的 id 代表返回值。 举个AF中的源码例子： 1 NSURLSessionConfiguration *configuration &#x3D; [NSURLSessionConfiguration ephemeralSessionConfiguration];2 NSURLSession *session &#x3D; [NSURLSession sessionWithConfiguration:configuration];3#pragma GCC diagnostic push4#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;5 NSURLSessionDataTask *localDataTask &#x3D; [session dataTaskWithURL:nil];6#pragma clang diagnostic pop7 IMP originalAFResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));8 Class currentClass &#x3D; [localDataTask class];9 10 while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;11 Class superClass &#x3D; [currentClass superclass];12 IMP classResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));13 IMP superclassResumeIMP &#x3D; method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));14 if (classResumeIMP !&#x3D; superclassResumeIMP &amp;&amp;15 originalAFResumeIMP !&#x3D; classResumeIMP) &#123;16 [self swizzleResumeAndSuspendMethodForClass:currentClass];17 &#125;18 currentClass &#x3D; [currentClass superclass];19 &#125; Method看一下 Method 的定义： 1runtime.h2&#x2F;&#x2F;&#x2F; An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型3typedef struct objc_method *Method;45struct objc_method &#123;6 SEL method_name OBJC2_UNAVAILABLE;7 char *method_types OBJC2_UNAVAILABLE;8 IMP method_imp OBJC2_UNAVAILABLE;9&#125; 它是一个 objc_method 结构体指针 方法名 method_name 类型为 SEL，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。 方法类型 method_types 是个 char 指针，其实存储着方法的参数类型和返回值类型，即是 Type Encoding 编码。 方法实现 method_imp 指向方法的实现，本质上是一个函数的指针，就是前面讲到的 Implementation。 举个AF中的源码例子： 1static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;2 Method originalMethod &#x3D; class_getInstanceMethod(theClass, originalSelector);3 Method swizzledMethod &#x3D; class_getInstanceMethod(theClass, swizzledSelector);4 method_exchangeImplementations(originalMethod, swizzledMethod);5&#125; 应用场景： When we use method swizzling 1+ (void)load &#123;2 static dispatch_once_t onceToken;3 dispatch_once(&amp;onceToken, ^&#123;4 Class class &#x3D; [self class];5 6 SEL originalSelector &#x3D; @selector(prepareToPlay);7 SEL swizzledSelector &#x3D; @selector(recond_prepareToPlay);8 9 Method originalMethod &#x3D; class_getInstanceMethod(class, originalSelector);10 Method swizzledMethod &#x3D; class_getInstanceMethod(class, swizzledSelector);11 12 BOOL didAddMethod &#x3D; class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));13 &#x2F;*14 @return YES if the method was added successfully, otherwise NO (for example, the class already contains a method implementation with that name).15 如果方法添加成功，则返回YES，否则返回NO（例如，类已包含具有该名称的方法实现）16 *&#x2F;17 if (didAddMethod) &#123;18 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));19 &#125; else &#123;20 method_exchangeImplementations(originalMethod, swizzledMethod);21 &#125;22 &#125;);23&#125; Selector，Method，IMP 它们之间的关系可以这么解释：一个类（Class）持有一个分发表，在运行期分发消息，表中的每一个实体代表一个方法（Method），它的名字叫做选择子（SEL），对应着一种方法实现（IMP）。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"组件化方案","slug":"组件化方案","date":"2020-05-23T08:27:28.000Z","updated":"2020-07-02T10:51:49.000Z","comments":true,"path":"2020/2020-05-23-16:27:28/","link":"","permalink":"http://yoursite.com/2020/2020-05-23-16:27:28/","excerpt":"BeeHive框架全面解析——iOS开发主流方案比较","text":"BeeHive框架全面解析——iOS开发主流方案比较 • BeeHive框架全面解析——iOS开发主流方案比较• 一、BeeHive是什么？• 二、作为框架，BeeHive做了什么工作？• 三、BeeHive是怎么做应用代理解耦的？• BeeHive应用代理解耦• MLSOAppDelegate应用代理解耦• 应用代理解耦讨论• 四、BeeHive是怎么做模块间调用的？• BeeHive模块调用• CTMediator模块调用• 模块间调用的讨论• 五、BeeHive的开发支持功能• 六、我们的方案选择• Objective-C是否适合POP开发？• 选择方案• 参考文档 一、BeeHive是什么？ BeeHive是用于iOS应用开发的App模块化编程的框架实现方案，吸收了Spring框架Service的理念来实现模块间的API耦合。BeeHive框架代码已在GitHub开源，对这个框架不了解的同学可以先看一下开源库提供的介绍：BeeHive@github。 二、作为框架，BeeHive做了什么工作？ BeeHive框架提供的功能主要有以下几部分：• 应用代理解耦：解除AppDelegate代理方法中，不同业务代码的耦合。• 模块间调用解耦：解除不同模块间的\b过度耦合问题，提供更加清晰的调用方案。• 其他开发支持功能 三、BeeHive是怎么做应用代理解耦的？AppDelegate中的代码想要解除耦合，说到底还是要将代理事件分发到不同的业务代理类中。在BeeHive之前，我自己用过两种解耦组件：• FRDModuleManager：实现代理中所有方法，简单的将AppDelegate的单路代理改成多路代理。• MLSOAppDelegate：通过runtime的事件转发，将代理协议中的方法进行动态转发，在自己代码中没有实现所有代理方法。不知道还有没有其他的\b开源组件，单论以上两种，MLSOAppDelegate应该算是FRDModuleManager的增强版，所以下面我们把MLSOAppDelegate的方案来和BeeHive的方案进行比较。 笔者说明：一般\b应用代理解耦的文章会将代理事件分发到的类称之为模块module，但是为了和下部分“模块间调用”中的模块概念区分，我们就将应用代理解耦中常用的Module称之为“模块代理类”。 BeeHive应用代理解耦统一基类 + 全局上下文参数 + 事件二次分发BeeHive提供了统一的AppDelegate基类BHAppDelegate，所有代理事件的参数全部保存到全局上下文对象BHContext中，由管理模块代理类的BHModuleManager从BHContext里把参数取出来然后通过BHModuleEventType枚举类型进行二次分发。将模块代理类注册进BHModuleManager，BeeHive提供了多种方法： 在模块代理类+ (void)load方法中调用[BeeHive registerDynamicModule:[self class]];; 在模块代理类的implementation中插入宏BH_EXPORT_MODULE(NO);此方法实质上和上面相同； 类似Java注解的形式@BeeHiveMod(ShopModule); 通过[BHContext shareInstance].moduleConfigName = @&quot;BeeHive.bundle/BeeHive&quot;;指定的文件加载。 应用代理解耦功能涉及到的类型有：• BHAppDelegate• BHModuleProtocol• BHModuleManager• BHAnnotation• BHContext \b优点： 业务代码的AppDelegate只要继承基类，不需要实现具体的代理方法； 扩展了模块生命周期\b，增加了modSetUp、modInit和modSplash方法； 模块代理类在业务代码中注册或者模块代理类自动注册时，会按照Level和Priority进行排序，模块代理类被调用的顺序可控； 模块代理类支持异步加载； 支持自定义事件。 不足： 因为有统一基类，对业务代码有侵入； 因为BeeHive对AppDelegate方法进行了\b二次封装，所以当系统代理方法增加、删除、变动时，BeeHive需要同步修改； 通过Level和Priority进行模块代理类的排序，其实质上存在逻辑耦合； 未支持UIResponder中的事件； MLSOAppDelegate应用代理解耦统一基类 + 事件转发该组件提供了基类MLSOAppDelegate，基类使用forwardInvocation将接收到的方法全部转发到MLAppServiceManager管理的所有模块代理类列表中。注册模块代理类，该组件也提供了多个方法： 通过MLAppServiceManager的registerServiceWithPlistFile方法加载配置文件； 在模块代理类+ (void)load方法中调用registerService方法; 通过ML_EXPORT_SERVICE宏定义自动注册；实质与上一种相同；优点： 业务代码的AppDelegate只要继承基类，不需要实现代理方法； 现有代理协议的方法增减变动时不需要同步修改； 通过配置文件主动注册时，调用顺序可控；不足： 需要支持新的协议时，需要同步修改；比如iOS10系统的推送； 在load方法内自动注册时，调用顺序不可控； 未分发UIResponder中的事件； 应用代理解耦讨论通过上面的比较，两种方案的区别主要在于模块代理类的执行顺序以及对代理方法变动的兼容性两方面。 模块代理类的执行顺序模块代理类的执行顺序只是个逻辑问题，相对来说BeeHive的方案比较满足我们的业务要求。不过我们在此不妨思考一下，模块代理类的执行顺序实质上是个什么问题。所谓的顺序，我们拆分到最细的层次上，其实就是两个模块代理类谁先谁后的问题。那么，执行顺序的问题，实质上就是模块\b代理类之间的耦合问题。耦合关系一般是两者之间的，所以解决问题时具体方案涉及的对象一旦超出了两者，那么就存在冗余的耦合。而通过Priority进行控制就是这样的方案。比如，现有A，B，C，D四个模块，其中B依赖A，C依赖B，D依赖A，那么现在设定他们的Priority分别为A=1，B=10，C=20，D=30（\b数字越小优先级越高）。但是有一天，因为新的需求，B模块也需要依赖D模块了。那么按照Priority的规则，我们需要调整B的Priority，使之大于D的Priority，比如设置B=40。但这样设置的话就破坏了C依赖B的关系。当然，我们也可以将D的Priority\b设置为比B更小，这样就不会有问题。但是我们在这里举这个例子的\b目的在于解释，Priority的方案会使得模块间的依赖关系更加复杂，两个模块间的依赖关系可能影响到其他模块间的依赖关系。那么，如果回归到最理想的状态，我们是否可以通过模块代理类间的耦合关系指定相对的加载顺序，\b类似Masonry这样的布局组件。比如： 1• + (void)load &#123;2• [[FWModuleDelegateManager sharedInstance] registeModuleDelegate:[FWPushModuleDelegate class] forName:@&quot;FWPush&quot; after:@[@&quot;FWUserCenterModuleDelegate&quot;, @&quot;FWLocationModuleDelegate&quot;]];3• 4• [[FWModuleDelegateManager sharedInstance] registeModuleDelegate:[FWPushModuleDelegate class] forName:@&quot;FWPush&quot; forIndex:0];5• &#125; 当然，我们上面的代码只是个简单的设想，实际的实现可能会更加复杂，比如，如果考虑到BeeHive支持的模块代理类异步加载的特性，那么这个相对执行顺序的方案可能就需要通过信号量或者队列的手段来确保不同线程下模块代理类的执行顺序了。在这里，本文暂时只做讨论，不给出实际方案。 代理方法变动的兼容性如果说上一个问题实际上只是个逻辑问题，并不存在技术可能性上的是与非。那么对代理方法变动的兼容性，则是技术方案的实质所在。以BeeHive的方案，实际上是抛弃了灵活性的考量，这样限制了它在这一点上的优化空间。 四、BeeHive是怎么做模块间调用的？模块间调用解决的是模块间的依赖耦合问题。常见的处理方案有以下三种：• URLRouter：将不同的模块定义成为不同的URL，通过URL的形式进行跨模块调用。• Target-Action：利用OC的runtime能力，动态的调用指定Target的action；• ProtocolClass：模块实现指定的协议，依赖方通过协议对象以及协议方法对模块进行访问；路由的方案限制比较多，我们在此比较一下后两种方案。BeeHive模块调用ProtocolClass / RouterBeeHive的模块都必须实现一个继承自BHServiceProtocol的唯一自定义协议，此协议中定义自己想要公开的方法，是用来给其他模块调用使用的。每个模块的自定义协议可以统一放在一个pod中，以中介者模式解决网状依赖的问题。而且该pod只会被具体的模块依赖，并不会依赖具体的模块。完全符合面向对象的依赖倒置原则——抽象不应该依赖于具体实现，具体实现应该依赖于抽象。将模块注册进入BHServiceManager中，BeeHive也提供了多种方法： 在模块代理类中手动注册[[BeeHive shareInstance] registerService:@protocol(TradeServiceProtocol) service:[BHTradeViewController class]];; 通过注解的形式注册@BeeHiveService(HomeServiceProtocol,BHViewController); 通过[BHContext shareInstance].serviceConfigName = @&quot;BeeHive.bundle/BHService&quot;;指定的配置文件加载。BeeHive另外还提供了\b通过路由BHRouter进行模块间调用的方案。模块间调用涉及的类型有：BHServiceProtocolBHServiceManagerBHRouter 不足： 有基础协议，存在代码\b侵入，但其中并未封装通用性的协议方法； BHServiceManager注册时通过协议识别模块，因此每个模块必须定义自己的协议； 通过配置文件注册时，未提供属性注入； 因为模块通过BeeHive统一注册后创建，所以Service之间的依赖，可能导致Service在注册前使用；因而需要控制Service的加载顺序；优点： 模块不存在\b或未注册时，不会获取到实例，可以灵活处理；另外，因为暂时没有弄清BHRouter的使用场景，我实在分不清“支持Router式调用”这是BeeHive框架的优点还是不足。 CTMediator模块调用Target-ActionCTMediator的方案中，每个模块需要定义自己的Target对象，作为公共方法声明，其中定义的Action都是给其他模块调用使用的。为了解决网状依赖的问题，可以为每个模块定义一个CTMediator\b的category对Target进行二次封装，这些category放在统一的pod中，作为一个中介者。按正常的逻辑，这个统一pod是会依赖具体的模块的，但是CTMediator的方案中，是利用runtime调用对应的Target-Action，所以解除了直接的代码依赖。不足： Target无基础类型，缺乏抽象，模块需要自己实现Target-Action; 当模块不存在时，无法\b提前处理，只能设置默认处理方法； category中都是硬编码，修改时会比较麻烦。优点： Target无基础类型，所以无侵入性； 模块不需注册; 两层封装，保证灵活性； 和应用间的Route跳转可以更灵活的对接； 模块间调用的讨论这个模块间调用的问题其实就是“依赖倒置”\b所解决的问题。BeeHive的方案应该是\b依赖倒置原则的标准实现方案，而CTMediator则是充分使用了OC的特性剑走偏锋。而CTMediator之所以需要这样处理，实质上就是因为它追求代码的无侵入性以及免注册，所以Target没有统一的基础类型。如果增加一个基础的Target类，同样可以像BeeHive\b的方案一样，完美的符合依赖倒置原则。而哪个适合你，就要看自己的取舍了。 五、BeeHive的开发支持功能• 环境切换：BHContext类中定义了env用来标识当前的环境类型，只不过这个功能太简单了些。• 时间统计工具：BHTimeProfiler• 看门狗，用来检测主线程占用：BHWatchDog因为本次重点是讨论框架，所以这些内容暂不详述。 六、我们的方案选择Objective-C是否适合POP开发？POP：Protocol-Oriented Programming在\b看了这么多框架的优劣后，想请大家思考个问题：Objective-C开发是否适合面向协议编程？我个人觉得\bPOP的关键点有两点，一是声明与实现的隔离，二是对于多态的支持。而对于Objective-C来说，声明与实现的隔离，这在.h与.m中已经实现，虽然只是表面的，并没有做到完全解耦；但很多时候的封装性已经可以满足。而对于多态的支持，很多时候其实就是程序能力的扩展，在这一方面Objective-C是通过Category实现的。因此，OC对于POP似乎没有迫切的需求。 选择方案本着学以致用的原则，我们如果要开发项目，需要选定一个确定的框架方案，那么综合以上的分析比较，我个人的倾向方案是：基于MLSOAppDelegate进行优化，增加BeeHive的优点（支持顺序设定、异步加载），支持相对顺序 + 基于CTMediator进行优化（增加Target预检测），\b业务层增加部分抽象以上是我的答案，如果是你，你会选择什么呢？ 参考文档 BeeHive，一次iOS模块化解耦实践 BeeHive —— 一个优雅但还在完善中的解耦框架 iOS大型项目解耦方案有难度？BeeHive设计优化来帮助 BeeHive@github","categories":[{"name":"架构知识","slug":"架构知识","permalink":"http://yoursite.com/categories/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"组件化","slug":"组件化","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"架构概念","slug":"架构概念","date":"2020-05-23T08:26:15.000Z","updated":"2020-07-02T10:51:56.000Z","comments":true,"path":"2020/2020-05-23-16:26:15/","link":"","permalink":"http://yoursite.com/2020/2020-05-23-16:26:15/","excerpt":"组件、插件、模块、子应用、库、框架等概念辨析","text":"组件、插件、模块、子应用、库、框架等概念辨析 网上有许多讲组件化、模块化等概念的文章，但大家一般都是将这两个概念混为一谈的，并没有加以区分。而且实际上许多人对于组件、插件、模块、子应用等概念的区别也不甚明了，甚至于许多博客文章专门解说这几个概念都有些谬误。之前已经写了一篇文章专门对组件和模块两个概念进行辨析，现在我们对于更多的概念在更高的层次上进行辨析。想分清这几个概念我觉得结合一下软件的渐进式开发场景更容易理解。但是下面的篇幅会比较长，所以按惯例还是先说结论，不耐烦的同学可以先看： 1.概念区别• 组件：代码重用，功能相对单一或者独立，无统一接口。组件化开发的成果是基础库和公共组件。• 插件：近乎组件，有统一接口• 模块：高内聚，松耦合，功能相对复杂，有多个统一接口。模块化开发的基础是框架。• 子系统：高于模块，需要生命周期管理。子系统开发的基础是容器。 1.1.组件和插件插件的概念比较形象，一般存在一个“插拔”过程，所以要求可插拔的插件有一个相同的接口（这里所说的接口只是概念上的接口，即调用方法及参数等）。而组件是不存在这个\b相同接口的。拿我们最常见的网络请求功能举例，无论哪种开发语言，github上可能都有多种网络请求组件，那么对于一个\b项目而言，从一个\b网络组件ComponentA切换为另一个网络组件ComponentB是基本无法做到调用方法不改动的。而如果把网络请求组件插件化，即在组件外层抽象一层\b统一化的调用接口NetworkInterface，然后将当前使用网络请求组件ComponentA包装成实现该接口的网络请求插件PluginA。那么如果以后需要将使用的ComponentA切换为ComponentB，那么只需要将ComponentB包装成PluginB并插入到应用中\b即可。实际调用时，业务代码还是调用NetworkInterface，不用做任何修改。从上面这个例子我们可以看出，插件和组件的\b实质区别就在于通过统一接口隔绝业务代码对于组件的直接依赖，这也是我们常听到的所谓的“项目开发时应该把第三方组件封装一下再用”。 1.2.组件和模块两者的实质区别在于：组件化开发是纵向分层，模块化开发是横向分块。所以，模块化并没有要求一定组件化，就是说进行模块化拆分时你可以完全不考虑代码重用，只是把同一业务的代码做内聚整合成不同的模块。只不过这样得到的成果相对简单，我们一般不会这样而已。组件化就比如项目中公共的alert框，它的出现其实是基于代码复用的目的，所以我们把它封装，并给多个地方使用。而模块化就比如一个资讯列表界面，它本身可能只在一个地方使用，没有复用的需求，但我们也要把它封装成模块，这是高内聚的要求，我们不应该把资讯相关的代码在项目中放得到处都是。但像这样的简单模块只是轻模块，统一接口较少。而统一定义的接口越多，其实和主应用的耦合就越高，也便是重模块。而路由就是解决高耦合问题的，不过耦合问题不是模块化开发的需求，只不过我们一般都会在这个时间考虑这一事情而已，就像我们不会只做模块化开发同时不做组件化开发一样。 1.3.模块和子应用模块和子应用的区别与组件和插件的区别有点像，都在于一个统一接口。子应用我们不常提，但其实并不少见，像微信小程序，钉钉中的第三方应用还有企业OA应用中集成的周边功能模块都应该属于子应用的概念。对于模块而言，它暴露给\b外部调用的接口一般很少，最常见的就是上面提到的路由规则，相当于可以让外部通过路由规则展示它。而子应用需要的就不只是一个展示接口，它可能需要动态的控制子应用的生命周期，以及其他功能上的信息交互（比如，账户信息的同步），甚至于要做到类似插件那样的插拔效果。所以子应用必然是接口化的，而模块则没有硬性的要求。 1.4.库和框架除了上面这四种概念，还有两个是我们开发中常遇到的：库和框架。库，或者基础库，概念上偏近于各种工具\b积累成的集合，是软件代码的层面是分层的概念，所以对应组件化。基础库甚至可以看做是一个大的组件。而框架顾名思义是结构化的，是相对整体的一个概念，所以应用于模块化，甚至是子应用化。比如在iOS中，RAC是一个库，而基于此的一套MVVM的具体实现成果（单页面的文件结构，多页面的交互等等）才叫框架。因为框架本身就有架构思想在里面。 2.渐进式辨析上面讲了一下几个概念的区别，当然这几个概念在服务端开发和客户端开发领域可能有些微差别，我们就不深究了。想要更深入的了解这些概念的区别，我准备拿一个渐进式开发移动端项目的例子进行辨析。首先我们定义一个虚拟的产品——一款知识类应用，包含常见的资讯、问答、学院、直播等功能。接下来我们从设计的角度逐步拆分这个产品。 2.1原始态如果开发时没有考虑任何组件化、模块化开发，那么此应用的所有功能都是堆积在一起的，总结起来就是代码特点就是高耦合，低内聚，无重用。面对这样的一堆代码，\b技术经理可能要让你做一下代码重构，这就是你下一步的工作。 2.2组件\b那么你进行代码重构的第一步是什么呢？答：将工程中重复的代码合并成为一份，也就是重用。如果让我们来看组件化开发的定义，它的着重点就是代码重用。那这一步最后的结果就是提炼出一个个组件给不同的功能使用。这里我们可以看一下其中的依赖关系：具体功能依赖提炼出来的组件，组件本身之间可能也有依赖关系，但一般不多。所以我们总结组件化开发的原则就是高重用，低耦合。当然这只是相对而言。基于这样的认识，我们甚至于可以把资讯、问答、学院、直播等功能封装成组件，只不过这些组件比较大，依赖可能多些，不过本质上没有多少区别。就在你进行重构的过程中，这时需求来了：运营人员要求首页顶部的九宫格样式工具栏可动态配置，通过服务端数据修改显示功能，并调用对应的功能页面。 2.3插件代码重构从来不是超然物外的，在进行过程中接到新需求也是常有的事情。那么，对于这样一个需求，应该怎么考虑呢？这个动态化需求很普遍，只不过这里有一个隐性要求——既然需求中要求功能动态配置，那么调用功能的地方就不知道功能的具体实现。所以最终的方案中被调用功能必须有统一接口。我们这里说的接口只是编程领域的抽象概念，并非是指具体语言的interface或者protocol。而有了这一统一接口，其配置功能其实就是“插拔”\b过程了。这样的成果实质上已经是插件了。插件可以解释成可插拔式组件，它的核心就是不同功能实现提供统一接口。项目中插件化的例子其实也不少，再举一个例子：比如资讯和问答功能使用的弹框样式不同，但是在两个功能内部其弹框样式是一致的。面对这样的问题，你在重构时可能会简单的封装出两个组件AlertA和AlertB，分别给两个功能使用。这样确实很便捷，而且适合当下的场景，但是从设计或者长远发展的角度上来考虑，如果资讯里面弹框样式需要\b换成和问答一样，甚至其他样式，那么基于现有的方法，你就需要修改资讯功能中所有调用弹框的地方。所以插件化是解决这个问题的好办法：定义AlertInterface接口给具体业务功能使用，并实现AlertPluginA、AlertPluginB，在外面给不同的功能指定不能的插件即可。 2.4模块这时候项目的组件化拆分完成，技术经理说以后不同的模块会交由不同的人来维护，各人维护各自负责的代码。这个需求初看上去只是项目管理上的需求，但实际执行时若资讯、问答、学院、直播分别由四个人维护，那么他们虽然大部分代码是相互隔离的，但仍然会有相当\b一部分代码耦合在一起，有时候会同时修改同一个代码文件。这时候要做的自然就是模块化。为什么是模块化呢？按照模块的定义，它是以关注点进行划分的，而关注点说到底就是功能，也就是说根据我们上面的例子，资讯、问答、学院、直播可以分成不同的模块。我们最开始定义这个虚拟产品的时候说，它有三个特点——高耦合、低内聚、无重用。而第一点组件化开发主要是解决了重用问题，提升了部分内聚，而耦合问题则没有涉及。所以说我们上面可以将这个产品在逻辑上划分为资讯、问答、学院、直播四个模块，但在代码层面上它们却不是四个模块，因为它们的代码都是混杂在一起的。比如产品首页，可能推荐了部分资讯、显示了热门问答、推送了目前的直播，而这些功能的代码则是写在一起的；再比如程序启动的时候，这四个模块都需要初始化一些数据，而初始化数据的代码也是写在一起的。而模块化开发就是为了解决这一问题，即提高内聚，将分属同一模块代码放到一起；降低耦合，将不同模块间的耦合程度弱化。高内聚是这一步的目标。但现状是有许多地方会用到多个模块，比如启动的时候会调用四个模块，首页会展示三个模块的界面。如果要高内聚，那么必然需要这些模块为不同的场景提供相同的方法，这就是说所有模块要实现同一套多个接口。而低耦合其实并非是模块化开发的要求，其实更多时候是基于产品上的动态化要求，所以最常见的解决方案就是路由机制。讲到这里，我们可以看到模块化和组件化的区别就已经很明显了。对于一般应用而言，代码设计优化到这一步就很好了，无论是代码可读性、可维护性、工作协作效率都得到了保障。不过为了讲到我们上面\b所说的所有概念，我们不妨皮一下，给自己提点需求：产品经理想把学院模块单独提出来做一个APP，但是因为技术经理反映\b开发资源有限，不能给这个APP配备独立的开发人员，所以最终的结果是这个APP的功能和原应用中的学院模块使用同一套代码，且功能相同。 2.5子应用对于开发人员来说，这也不能算多困难的需求，只需要再创建一个新工程，将学院模块代码引用过来并显示即可。这个方案简单直接，即便后面再把直播分离出单独APP我也可以这样来做。但是，有没有\b觉得这个方案和我们之前提到的Alert的例子有些神似，在这个方案中，新的工程必然直接耦合具体的模块代码，你需要在里面编写很多初始化代码。而这样的代码在单独的APP中和原APP中是相当类似的。按照《重构》一书中的提法，这是明显的坏味道，我们应该在工程和模块代码之间抽象出一层接口，使两者解除直接耦合，这样我们甚至可以做到只需要配置就可以将一个模块变成一个新的APP。(或许在这个例子中，有些过度设计了，但是原谅我举不出更合情理的例子TAT)上面方案的成果，实际上就把学院模块编程了学院子应用，而这个子应用被原APP和新的独立APP所使用。在概念上，子应用比模块的范围更大，子应用要求能在主应用里运行，也要求必要时可以自己运行，那么就必然要求子应用要提供生命周期接口，和主应用必要时保持一致。其实在\b上面一步的模块化开发中，有的时候也会有生命周期接口的要求，只不过并非强制，而子应用的设计中则是必须要考虑的。 3.总结到此，我们就把组件、插件、模块、子应用四个不同程度的设计概念\b异同讲完了，希望读者能有所得。文章中若有其他不足之处，恳请不吝赐教。","categories":[{"name":"架构知识","slug":"架构知识","permalink":"http://yoursite.com/categories/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"架构概念","slug":"架构概念","permalink":"http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5/"}]},{"title":"随手记录📝","slug":"日常笔记📒","date":"2020-03-19T07:40:37.000Z","updated":"2020-12-28T10:37:53.335Z","comments":true,"path":"2020/2020-03-19-15:40:37/","link":"","permalink":"http://yoursite.com/2020/2020-03-19-15:40:37/","excerpt":"UML类图","text":"UML类图 —————▷ 继承———–▷实现接口 —————&gt; 关联———–&gt; 依赖 ◆————&gt; 组合◇————&gt; 聚合 ◦ 接口 一些传送门设计模式 [iTerm2] (https://www.cnblogs.com/xishuai/p/mac-iterm2.html) 好记性不如烂笔头/用户/Xuebiao/Library/Developer/Xcode/usr/local/bin ../ 上层目录./ 当前目录cal 日历时间bc 计算器 quit退出cd - 上次查看的目录cd .. 返回上层目录cd 根目录 快捷键：显示隐藏文件：command + shift + . chmod 755 kspod 权限 ./kspod KSMallCartModule 1.0.0.0 ‘first commit’ pod ‘KSMallOrderModule’, :path =&gt; ‘../KSPrivatePods/KSMallOrderModule/‘ #订单模块 swift-alogrithm-club上的数据结构 增加最低速度时间git config –global http.lowSpeedLimit 0git config –global http.lowSpeedTime 999999 git config –global url.”https://gitclone.com/github.com/&quot;.insteadOf https://github.com/ VALID_ARCHS x86_64 Mach-O 是Mach object的缩写，是Mac\\iOS上用于存储程序、库的标准文件格式。Mach-O介绍dyld 动态链接器 /usr/lib/dylddSYM 符号文件 strings libCWLog.a | grep ‘UIPasteboard’ 查看静态库支持哪些系统架构lipo -info libjpush-ios-3.3.3.a Hexo博客地址 参考链接https://www.jianshu.com/p/860d3e0fff58https://segmentfault.com/a/1190000017986794 hexo n “我的博客” == hexo new “我的博客” //新建文章hexo g == hexo generate //生成hexo s == hexo server //启动服务预览hexo d == hexo deploy //部署 hexo server //Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s //静态模式hexo server -p 5000 //更改端口hexo server -i 192.168.1.1 //自定义 IPhexo clean //清除缓存，若是网页正常情况下可以忽略这条命令 部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。hexo clean 部署上传hexo g -d Podpod install –repo-update 更新慢的问题：无论是执行pod install还是pod update都卡在了Analyzing dependencies不动: pod install –verbose –no-repo-update pod update –verbose –no-repo-update gem which cocoapodswhere is kspod 查找一个文件或目录find / -name validator.rb pod检查当前安装版本列表gem list –local | grep cocoapods卸载不用的版本sudo gem uninstall cocoapods 1.5.3安装指定版本sudo gem install cocoapods -v 1.6.1安装最新版本sudo gem install cocoapods 上传pod库到cocoapods官方spec仓库git tag -123456789 0.1.0 -m “xxxxxxxxxxxx”pod trunk register yourEmail yourName –verbosepod trunk push xxxxxxxxx.podspec –allow-warnings Pod私有库制作教程http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/ ####gems目录cd /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.8.4 私有库i386上传问题，修改validator.rb文件 1def xcodebuild(action, scheme, configuration)2 require &#39;fourflusher&#39;3 command &#x3D; %W(clean #&#123;action&#125; -workspace #&#123;File.join(validation_dir, &#39;App.xcworkspace&#39;)&#125; -scheme #&#123;scheme&#125; -configuration #&#123;configuration&#125;)4 case consumer.platform_name5 when :osx, :macos6 command +&#x3D; %w(CODE_SIGN_IDENTITY&#x3D;)7 when :ios8# command +&#x3D; %w(CODE_SIGN_IDENTITY&#x3D;- -sdk iphonesimulator)9# command +&#x3D; Fourflusher::SimControl.new.destination(:oldest, &#39;iOS&#39;, deployment_target)10# xcconfig &#x3D; consumer.pod_target_xcconfig11# if xcconfig12# archs &#x3D; xcconfig[&#39;VALID_ARCHS&#39;]13# if archs &amp;&amp; (archs.include? &#39;armv7&#39;) &amp;&amp; !(archs.include? &#39;i386&#39;) &amp;&amp; (archs.include? &#39;x86_64&#39;)14# # Prevent Xcodebuild from testing the non-existent i386 simulator if armv7 is specified without i38615# command +&#x3D; %w(ARCHS&#x3D;x86_64)16# end17# end18 command +&#x3D; %w(--help)19 when :watchos 图片资源https://www.pexels.com/search/cat/ 1.48K张https://unsplash.com/search/photos/cat 3.9K张https://pixabay.com/zh/images/search/cat/ objc源码：https://opensource.apple.com/tarballs/objc4/https://objccn.io Flutter：https://flutterawesome.comhttps://flutter-io.cn/ 同步官网文档https://book.flutterchina.club flutter开发实战https://startflutter.com Swift：https://docs.swift.org/swift-book/LanguageGuide/TheBasics.htmlhttps://swiftgg.gitbook.io/swift/ RXSwift:https://beeth0ven.github.io/RxSwift-Chinese-Documentation/https://mcxiaoke.gitbooks.io/rxdocs/content/ 想看的书📚《结构化思维》《时间与任务管理》《有效沟通六要素》《可复制的领导力》","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"统一建模语言(UML)简介","slug":"统一建模语言-UML-简介","date":"2019-12-06T13:02:23.000Z","updated":"2020-10-23T09:35:56.000Z","comments":true,"path":"2019/12-06-23:00:01/","link":"","permalink":"http://yoursite.com/2019/12-06-23:00:01/","excerpt":"统一建模语言简介","text":"统一建模语言简介 统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。 统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。 UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。 这里主要介绍软件设计模式中经常用到的类图，以及类之间的关系。 类、接口1. 类类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。(1) 类名（Name）是一个字符串，例如，Student。(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示： 1[可见性]属性名:类型[&#x3D;默认值] 2例如：-name:String Tips：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。省略这些修饰符表示具有package（包）级别的可见性。 (3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示： 1[可见性]名称(参数列表)[:返回类型] 2例如：+display():void。 图 1 所示是学生类的 UML 表示。 2.抽象类在类图中以斜体表示一个抽象类或者抽象操作，抽象类是不能实例化的，一般至少包含一个抽象操作。 3.接口接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。 图 2 所示是图形类接口的表示。 类之间的关系在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。 1. 依赖关系依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。 图 4 所示是人与手机的关系图，人通过手机的语音传送方法打电话。 2. 关联关系关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。 关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。 在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。 图 5 所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。 3. 聚合关系聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。 图 6 所示是大学和教师的关系图。 4. 组合关系组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。 在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。 图 7 所示是头和嘴的关系图。 5. 泛化（继承）关系泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类， 其类图如图 8 所示： 6. 实现关系实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具。其类图如图 9 所示：","categories":[{"name":"编程思想","slug":"编程思想","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://yoursite.com/tags/UML/"}]},{"title":"六大设计原则","slug":"六大设计原则","date":"2019-12-06T07:11:26.000Z","updated":"2020-03-23T07:42:43.000Z","comments":true,"path":"2019/12-06-15:11:26/","link":"","permalink":"http://yoursite.com/2019/12-06-15:11:26/","excerpt":"1、单一职责原则","text":"1、单一职责原则 单一职责原则的英文名称是Single Responsibility Principle ，简称SRP。这个设计原则备受争议，只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的。 定义：There should never be more than one reason for a class to change. 应该有且仅有一个原因引起类的变更。 理解：不同的类具备不同的职责，各司其职。做系统设计时，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。 优点：类的复杂性降低，实现什么职责都有清晰明确的定义；可读性提高，复杂性降低，那当然可读性提高了；可维护性提高，可读性提高，那当然更容易维护了；变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 总结：一个类只承担一个职责。单一职责原则提出了一个编写程序的标准，用”职责“或”变化原因“来衡量接口或类设计得是否优良，但是”职责“和”变化原因“都是不可度量的，因项目而异，因环境而异。 2、里氏替换原则它有两种定义：第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.(如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。) 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.(所有引用基类的地方必须能透明地使用其子类的对象。) 第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适用。 理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。 总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。 3、依赖倒置原则依赖倒置原则（Dependence Inversion Principle, DIP） 定义：High level modules should not depends upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 理解：1.高层模块不应该依赖低层模块，两者都应该依赖其抽象； 2.抽象不应该依赖细节； 3.细节应该依赖抽象。 应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。 总结：面向接口编程，提取出事务的本质和共性。 4、接口隔离原则什么是接口呢？它分为两种：实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的描述，这是一种接口。比如你定义Person这个类，然后使用Person zhangSan =new Person()产生了一个实例，这个实例要遵从的标准就是Person这个类，Person类就是zhangSan的接口。Java中的类也是一种接口。 类接口（Class Interface），Java中经常使用的interface关键字定义的接口。 什么是隔离呢？它有两种定义：Clients should not be forced to depend upon interfaces that they don’t use.(客户端不应该依赖它不需要的接口。)The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应该建立在最小的接口上。) 理解：第一种定义：”客户端不应该依赖不需要的接口“，那依赖什么？依赖它需要的接口，客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，那就需要对接口进行细化，保证其纯洁性；再看第二种定义：”类间的依赖关系应该建立在最小的接口“，它要求是最小的接口，也是要求接口细化，接口纯洁，与第一个定义如出一辙，只是一个事物的两种不同描述。我们可以把两个定义概括为一句话：建立单一接口，不用建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少。 总结：一个接口只服务于一个子模块或业务逻辑；通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到”满身筋骨肉“，而不是”肥嘟嘟“的一大堆方法；已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！ 5、迪米特法则迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道的最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。 理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。 总结：一定要做到：低耦合、高内聚。 6、开闭原则定义：Software entities like classes,modules and functions should be open for extension but closed for modifications.(一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。) 理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。 总结：对软件实体的改动，最好用扩展而非修改的方式。","categories":[{"name":"编程思想","slug":"编程思想","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"iOS资料整理","slug":"iOS资料整理","date":"2019-12-03T07:15:15.000Z","updated":"2020-11-09T07:48:14.308Z","comments":true,"path":"2019/12-03-15:15:15/","link":"","permalink":"http://yoursite.com/2019/12-03-15:15:15/","excerpt":"传送门","text":"传送门 新浪微博iOS客户端架构与优化之路 MVVM实践干货 猿题库iOS客户端架构设计 Pod私有库制作教程 如何优雅的使用KVO 内存布局 iOS那些被忽略的框架 Mach-O","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"资料整理","slug":"资料整理","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"}]}]}