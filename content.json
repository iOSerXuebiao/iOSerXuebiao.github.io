{"meta":{"title":"XO的博客","subtitle":"","description":"","author":"XO","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"六大设计原则","slug":"六大设计原则","date":"2019-12-06T07:11:26.000Z","updated":"2019-12-06T10:53:27.921Z","comments":true,"path":"2019/12-06-15:11:26/","link":"","permalink":"http://yoursite.com/2019/12-06-15:11:26/","excerpt":"","text":"1、单一职责原则单一职责原则的英文名称是Single Responsibility Principle ，简称SRP。这个设计原则备受争议，只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的。 定义：There should never be more than one reason for a class to change. 应该有且仅有一个原因引起类的变更。 理解：不同的类具备不同的职责，各司其职。做系统设计时，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。 优点：类的复杂性降低，实现什么职责都有清晰明确的定义；可读性提高，复杂性降低，那当然可读性提高了；可维护性提高，可读性提高，那当然更容易维护了；变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 总结：一个类只承担一个职责。单一职责原则提出了一个编写程序的标准，用”职责“或”变化原因“来衡量接口或类设计得是否优良，但是”职责“和”变化原因“都是不可度量的，因项目而异，因环境而异。 2、里氏替换原则它有两种定义：第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.(如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。) 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.(所有引用基类的地方必须能透明地使用其子类的对象。) 第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适用。 理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。 总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。 3、依赖倒置原则依赖倒置原则（Dependence Inversion Principle, DIP） 定义：High level modules should not depends upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 理解：1.高层模块不应该依赖低层模块，两者都应该依赖其抽象； 2.抽象不应该依赖细节； 3.细节应该依赖抽象。 应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。 总结：面向接口编程，提取出事务的本质和共性。 4、接口隔离原则什么是接口呢？它分为两种：实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的描述，这是一种接口。比如你定义Person这个类，然后使用Person zhangSan =new Person()产生了一个实例，这个实例要遵从的标准就是Person这个类，Person类就是zhangSan的接口。Java中的类也是一种接口。 类接口（Class Interface），Java中经常使用的interface关键字定义的接口。 什么是隔离呢？它有两种定义：Clients should not be forced to depend upon interfaces that they don’t use.(客户端不应该依赖它不需要的接口。)The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应该建立在最小的接口上。) 理解：第一种定义：”客户端不应该依赖不需要的接口“，那依赖什么？依赖它需要的接口，客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，那就需要对接口进行细化，保证其纯洁性；再看第二种定义：”类间的依赖关系应该建立在最小的接口“，它要求是最小的接口，也是要求接口细化，接口纯洁，与第一个定义如出一辙，只是一个事物的两种不同描述。我们可以把两个定义概括为一句话：建立单一接口，不用建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少。 总结：一个接口只服务于一个子模块或业务逻辑；通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到”满身筋骨肉“，而不是”肥嘟嘟“的一大堆方法；已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！ 5、迪米特法则迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道的最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。 理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。 总结：一定要做到：低耦合、高内聚。 6、开闭原则定义：Software entities like classes,modules and functions should be open for extension but closed for modifications.(一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。) 理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。 总结：对软件实体的改动，最好用扩展而非修改的方式。","categories":[],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"iOS资料整理","slug":"iOS资料整理","date":"2019-12-03T07:15:15.000Z","updated":"2019-12-06T10:53:29.020Z","comments":true,"path":"2019/12-03-15:15:15/","link":"","permalink":"http://yoursite.com/2019/12-03-15:15:15/","excerpt":"","text":"传送门新浪微博iOS客户端架构与优化之路MVVM实践干货 猿题库iOS客户端架构设计","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]}