{"meta":{"title":"X的博客","subtitle":"","description":"","author":"X","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"随手记录📝","slug":"随手记录📝","date":"2020-03-19T07:40:37.000Z","updated":"2020-05-23T08:15:52.911Z","comments":true,"path":"2020/Thu Mar 19 2020 15:40:37 GMT+0800 (中国标准时间)/","link":"","permalink":"http://yoursite.com/2020/Thu%20Mar%2019%202020%2015:40:37%20GMT+0800%20(%E4%B8%AD%E5%9B%BD%E6%A0%87%E5%87%86%E6%97%B6%E9%97%B4)/","excerpt":"UML类图","text":"UML类图 —————▷ 继承———–▷实现接口 —————&gt; 关联———–&gt; 依赖 ◆————&gt; 组合◇————&gt; 聚合 ◦ 接口 一些传送门设计模式 [iTerm2] (https://www.cnblogs.com/xishuai/p/mac-iterm2.html) /用户/Xuebiao/Library/Developer/Xcode/usr/local/bin ../ 上层目录./ 当前目录cal 日历时间bc 计算器 quit退出cd - 上次查看的目录cd .. 返回上层目录cd 根目录 快捷键：显示隐藏文件：command + shift + . chmod 755 kspod 权限 ./kspod KSMallCartModule 1.0.0.0 ‘first commit’ pod ‘KSMallOrderModule’, :path =&gt; ‘../KSPrivatePods/KSMallOrderModule/‘ #订单模块 swift-alogrithm-club上的数据结构 Hexo博客地址 参考链接https://www.jianshu.com/p/860d3e0fff58https://segmentfault.com/a/1190000017986794 hexo n “我的博客” == hexo new “我的博客” //新建文章hexo g == hexo generate //生成hexo s == hexo server //启动服务预览hexo d == hexo deploy //部署 hexo server //Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s //静态模式hexo server -p 5000 //更改端口hexo server -i 192.168.1.1 //自定义 IPhexo clean //清除缓存，若是网页正常情况下可以忽略这条命令 部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。hexo clean 部署上传hexo g -d Podpod install –repo-update 更新慢的问题：无论是执行pod install还是pod update都卡在了Analyzing dependencies不动: pod install –verbose –no-repo-update pod update –verbose –no-repo-update 查找一个文件或目录find / -name validator.rb pod检查当前安装版本列表gem list –local | grep cocoapods卸载不用的版本sudo gem uninstall cocoapods 1.5.3安装指定版本sudo gem install cocoapods -v 1.6.1安装最新版本sudo gem install cocoapods Pod私有库制作教程http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/ ####gems目录cd /Library/Ruby/Gems/2.3.0/gems/cocoapods-1.8.4 私有库i386上传问题，修改validator.rb文件 1def xcodebuild(action, scheme, configuration)2 require &#39;fourflusher&#39;3 command &#x3D; %W(clean #&#123;action&#125; -workspace #&#123;File.join(validation_dir, &#39;App.xcworkspace&#39;)&#125; -scheme #&#123;scheme&#125; -configuration #&#123;configuration&#125;)4 case consumer.platform_name5 when :osx, :macos6 command +&#x3D; %w(CODE_SIGN_IDENTITY&#x3D;)7 when :ios8# command +&#x3D; %w(CODE_SIGN_IDENTITY&#x3D;- -sdk iphonesimulator)9# command +&#x3D; Fourflusher::SimControl.new.destination(:oldest, &#39;iOS&#39;, deployment_target)10# xcconfig &#x3D; consumer.pod_target_xcconfig11# if xcconfig12# archs &#x3D; xcconfig[&#39;VALID_ARCHS&#39;]13# if archs &amp;&amp; (archs.include? &#39;armv7&#39;) &amp;&amp; !(archs.include? &#39;i386&#39;) &amp;&amp; (archs.include? &#39;x86_64&#39;)14# # Prevent Xcodebuild from testing the non-existent i386 simulator if armv7 is specified without i38615# command +&#x3D; %w(ARCHS&#x3D;x86_64)16# end17# end18 command +&#x3D; %w(--help)19 when :watchos 图片资源https://www.pexels.com/search/cat/ 1.48K张https://unsplash.com/search/photos/cat 3.9K张https://pixabay.com/zh/images/search/cat/ objc源码：https://opensource.apple.com/tarballs/objc4/https://objccn.io Flutter：https://flutterawesome.comhttps://flutter-io.cn/ 同步官网文档https://book.flutterchina.club flutter开发实战https://startflutter.com Swift：https://docs.swift.org/swift-book/LanguageGuide/TheBasics.htmlhttps://swiftgg.gitbook.io/swift/ RXSwift:https://beeth0ven.github.io/RxSwift-Chinese-Documentation/https://mcxiaoke.gitbooks.io/rxdocs/content/ 想看的书📚《结构化思维》《时间与任务管理》《有效沟通六要素》《可复制的领导力》","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"统一建模语言(UML)简介","slug":"统一建模语言-UML-简介","date":"2019-12-06T13:02:23.000Z","updated":"2020-03-23T06:40:11.159Z","comments":true,"path":"2019/12-06-23:00:01/","link":"","permalink":"http://yoursite.com/2019/12-06-23:00:01/","excerpt":"统一建模语言简介","text":"统一建模语言简介 统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。 统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。 UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。 这里主要介绍软件设计模式中经常用到的类图，以及类之间的关系。 类、接口1. 类类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。(1) 类名（Name）是一个字符串，例如，Student。(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示： 1[可见性]属性名:类型[&#x3D;默认值] 2例如：-name:String Tips：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。省略这些修饰符表示具有package（包）级别的可见性。 (3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示： 1[可见性]名称(参数列表)[:返回类型] 2例如：+display():void。 图 1 所示是学生类的 UML 表示。 2.抽象类在类图中以斜体表示一个抽象类或者抽象操作，抽象类是不能实例化的，一般至少包含一个抽象操作。 3.接口接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。 图 2 所示是图形类接口的表示。 类之间的关系在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。 1. 依赖关系依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。 图 4 所示是人与手机的关系图，人通过手机的语音传送方法打电话。 2. 关联关系关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。 关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。 在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。 图 5 所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。 3. 聚合关系聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。 聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。 图 6 所示是大学和教师的关系图。 4. 组合关系组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。 在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。 在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。 图 7 所示是头和嘴的关系图。 5. 泛化（继承）关系泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类， 其类图如图 8 所示： 6. 实现关系实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具。其类图如图 9 所示：","categories":[],"tags":[{"name":"UML","slug":"UML","permalink":"http://yoursite.com/tags/UML/"}]},{"title":"六大设计原则","slug":"六大设计原则","date":"2019-12-06T07:11:26.000Z","updated":"2020-03-23T07:42:43.234Z","comments":true,"path":"2019/12-06-15:11:26/","link":"","permalink":"http://yoursite.com/2019/12-06-15:11:26/","excerpt":"1、单一职责原则","text":"1、单一职责原则 单一职责原则的英文名称是Single Responsibility Principle ，简称SRP。这个设计原则备受争议，只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的。 定义：There should never be more than one reason for a class to change. 应该有且仅有一个原因引起类的变更。 理解：不同的类具备不同的职责，各司其职。做系统设计时，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。 优点：类的复杂性降低，实现什么职责都有清晰明确的定义；可读性提高，复杂性降低，那当然可读性提高了；可维护性提高，可读性提高，那当然更容易维护了；变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 总结：一个类只承担一个职责。单一职责原则提出了一个编写程序的标准，用”职责“或”变化原因“来衡量接口或类设计得是否优良，但是”职责“和”变化原因“都是不可度量的，因项目而异，因环境而异。 2、里氏替换原则它有两种定义：第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.(如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。) 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.(所有引用基类的地方必须能透明地使用其子类的对象。) 第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适用。 理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。 总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。 3、依赖倒置原则依赖倒置原则（Dependence Inversion Principle, DIP） 定义：High level modules should not depends upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 理解：1.高层模块不应该依赖低层模块，两者都应该依赖其抽象； 2.抽象不应该依赖细节； 3.细节应该依赖抽象。 应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。 总结：面向接口编程，提取出事务的本质和共性。 4、接口隔离原则什么是接口呢？它分为两种：实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的描述，这是一种接口。比如你定义Person这个类，然后使用Person zhangSan =new Person()产生了一个实例，这个实例要遵从的标准就是Person这个类，Person类就是zhangSan的接口。Java中的类也是一种接口。 类接口（Class Interface），Java中经常使用的interface关键字定义的接口。 什么是隔离呢？它有两种定义：Clients should not be forced to depend upon interfaces that they don’t use.(客户端不应该依赖它不需要的接口。)The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应该建立在最小的接口上。) 理解：第一种定义：”客户端不应该依赖不需要的接口“，那依赖什么？依赖它需要的接口，客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，那就需要对接口进行细化，保证其纯洁性；再看第二种定义：”类间的依赖关系应该建立在最小的接口“，它要求是最小的接口，也是要求接口细化，接口纯洁，与第一个定义如出一辙，只是一个事物的两种不同描述。我们可以把两个定义概括为一句话：建立单一接口，不用建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少。 总结：一个接口只服务于一个子模块或业务逻辑；通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到”满身筋骨肉“，而不是”肥嘟嘟“的一大堆方法；已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！ 5、迪米特法则迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道的最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。 理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。 总结：一定要做到：低耦合、高内聚。 6、开闭原则定义：Software entities like classes,modules and functions should be open for extension but closed for modifications.(一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。) 理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。 总结：对软件实体的改动，最好用扩展而非修改的方式。","categories":[{"name":"编程思想","slug":"编程思想","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}]},{"title":"iOS资料整理","slug":"iOS资料整理","date":"2019-12-03T07:15:15.000Z","updated":"2020-03-23T06:41:14.810Z","comments":true,"path":"2019/12-03-15:15:15/","link":"","permalink":"http://yoursite.com/2019/12-03-15:15:15/","excerpt":"传送门","text":"传送门 新浪微博iOS客户端架构与优化之路MVVM实践干货 猿题库iOS客户端架构设计","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"资料整理","slug":"资料整理","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"}]}]}